SQL> --#>
SQL> --/<
SQL> CREATE OR REPLACE PACKAGE BODY logger
  2  -- ##########################################################################
  3  --   logger
  4  -- ##########################################################################
  5  is
  6    g_debug		       boolean := false;
  7    g_job_msg_dir	       varchar (32) := 'JOB_MSG_DIR';
  8    g_logfile_name	       varchar(255);
  9  
 10  
 11    type logger_dtl_type is table of logger_dtl%rowtype index by varchar(64);
 12  
 13    logger_dtls logger_dtl_type;
 14  
 15    g_job_log job_log%rowtype;
 16  
 17    function format_timestamp(timestamp in timestamp)
 18    return varchar
 19    is
 20  	 -- hack so as not to find MI as a bind variable
 21  	 my_timestamp varchar(256) :=  to_char (current_timestamp, 'YYYY-MM-DD HH24' || ':' || 'MISSXFF');
 22    begin
 23  	 my_timestamp := replace(my_timestamp,' ','T');
 24  	 return my_timestamp;
 25    end format_timestamp;
 26  
 27    function  logger_message_formatter  (
 28  	 job_log_id    in   pls_integer,
 29  	 job_msg_id    in   pls_integer,
 30  	 log_msg       in   varchar,
 31  	 log_level     in   pls_integer,
 32  	 caller_name   in   varchar default null,
 33  	 line_number   in   pls_integer default null,
 34  	 call_stack    in   boolean default false,
 35  	 separator     in   varchar default ','
 36  	) return varchar
 37    is
 38  	 my_log_msg  varchar2(32767) := REPLACE (log_msg, '"', '""');
 39  	 my_log_entry varchar2(32767);
 40  	 my_timestamp varchar(256);
 41  	 stack varchar(32767);
 42  	    -- my_text_field_end_separator varchar)  := '",';
 43    begin
 44  	 my_timestamp := format_timestamp(current_timestamp);
 45  
 46  	 if call_stack then
 47  	   stack := dbms_utility.format_call_stack;
 48  	 end if;
 49  	   --	   dbms_output.put_line('my_timestamp '||  my_timestamp);
 50  	 my_log_entry :=
 51  	   log_level	|| separator ||
 52  	   '"' ||my_timestamp  || '"' || separator ||
 53  	   '"' || my_log_msg   || '"' || separator ||
 54  	   '"' || caller_name  || '"' || separator ||
 55  	   line_number	|| separator  ||
 56  	   job_log_id	|| separator ||
 57  	   job_msg_id	|| separator ||
 58  	   '"' || stack || '"';
 59  	      -- dbms_output.put_line('log entry: ' || my_log_entry);
 60  	   return my_log_entry;
 61  	 end;
 62  
 63    function get_job_token
 64    return varchar
 65    is begin
 66  	 return format_timestamp(current_timestamp);
 67    end;
 68  
 69    function get_new_job_log_id
 70    return number
 71    is begin
 72  	 return job_log_id_seq.nextval;
 73    end;
 74  
 75    --%#Tracing
 76    --%<
 77    procedure set_trace (trace_level in pls_integer)
 78    --%>
 79    is
 80    begin
 81  	 DBMS_TRACE.set_plsql_trace (trace_level);
 82    end set_trace;
 83  
 84    --%<
 85    function get_my_tracefile_name
 86    return varchar
 87    --%>
 88    is
 89  	 tracefile_name varchar(4096);
 90  	 begin
 91  	     select value into tracefile_name
 92  	     from v$diag_info
 93  	     where name = 'Default Trace File';
 94  
 95  	     return tracefile_name;
 96  	 end get_my_tracefile_name;
 97  
 98    --%<
 99    function set_tracefile_identifier(job_nbr in number)
100    return varchar
101    --%>
102    is
103  	 identifier varchar(32) := 'job_' || to_char(job_nbr);
104    begin
105  	 execute immediate 'alter session set tracefile_identifier = ''' || identifier || '''';
106  	 return get_my_tracefile_name;
107    end set_tracefile_identifier;
108  
109  	 --%# Job DML
110  	 --%# job_msg
111  
112    procedure job_msg_insert (
113  	 job_log_id in pls_integer,
114  	 --	      g_next_log_seq_nbr in pls_integer,
115  	 log_msg_id in varchar,
116  	 short_message in varchar,
117  	 log_level in pls_integer,
118  	 caller_name in varchar,
119  	 line_number in pls_integer,
120  	 long_message in varchar
121  	)
122  	is
123  	  pragma autonomous_transaction ;
124  	begin
125  
126  	  if log_level = g_snap OR log_level <= g_job_log.msg_lvl then
127  	    insert into job_msg (
128  	      job_msg_id,    job_log_id,
129  	      -- log_seq_nbr,
130  	      log_msg_id,
131  	      log_msg,	     log_level, 	log_msg_ts,	     caller_name,
132  	      line_nbr,      log_msg_clob
133  	    )
134  	    values(
135  	      log_msg_id,    job_log_id,
136  	      -- g_next_log_seq_nbr,
137  	      log_msg_id,
138  	      short_message, log_level,     current_timestamp,	 caller_name,
139  	      line_number,   long_message
140  	   );
141  	   end if;
142  	end;
143  
144  	 --%# job_log
145  
146    procedure job_log_insert(rec in job_log%rowtype) is
147    begin
148  	 insert into job_log (
149  	   job_log_id,	   process_name,    thread_name,
150  	   status_msg,	   status_ts,	    -- tracefile_name
151  	   classname,		module_name,
152  	   job_token,	   logfile_name
153  	  ) values (
154  	    rec.job_log_id,  rec.process_name,	 rec.thread_name,
155  	    rec.status_msg,  current_timestamp, --  rec.tracefile_name,
156  	    rec.classname,   rec.module_name,
157  	    rec.job_token,   rec.logfile_name
158  	  );
159  
160  	 end;
161  
162    function job_step_insert (
163  	 step_name   in varchar,
164  	 step_info   in varchar default null,
165  	 classname   in varchar default null,
166  	 stacktrace  in varchar default null
167    ) return number
168    is
169  	 my_job_step_id number;
170    begin
171  	 insert into job_step (
172  	   job_step_id,   job_log_id, step_name, step_info,
173  	   classname,	  start_ts,   stacktrace
174  	 ) values (
175  	   job_step_id_seq.nextval, g_job_log.job_log_id, step_name, step_info,
176  	   classname,	current_timestamp,   stacktrace
177  	 ) returning job_step_id into my_job_step_id;
178  	 return my_job_step_id;
179    end job_step_insert;
180  
181    procedure job_step_finish (step_id in number) is
182    begin
183  	 update job_step
184  	 set end_ts = systimestamp
185  	 where job_step_id = step_id;
186    end job_step_finish;
187  
188    procedure begin_log (
189  	 logfile_name	in varchar,
190  	 logfile_directory in varchar default 'JOB_MSG_DIR',
191  	 process_name in varchar default null,
192  	 log_set      in varchar default null,
193  	 classname    in varchar default null,
194  	 module_name  in varchar default null,
195  	 status_msg   in varchar default null,
196  	 thread_name  in varchar default null,
197  	 log_level    in pls_integer default G_INFO,
198  	 trace_level  in pls_integer default G_INFO)
199  	 --%>
200  	 is
201  	   my_tracefile_name varchar(256);
202  	   my_job_token varchar(64) := get_job_token;
203  
204  	 begin
205  	   if g_debug then
206  	     dbms_output.put_line('begin_log() logfile_name "' || logfile_name || '"');
207  	   end if;
208  	   g_job_log.logfile_name := logfile_name;
209  	   g_job_log.directory_name := logfile_directory;
210  	     --g_job_log.job_log_id   := job_log_id_seq.nextval;
211  	   g_job_log.process_name := process_name;
212  	   g_job_log.classname	  := classname;
213  	   g_job_log.module_name  := module_name;
214  	   g_job_log.status_msg   := status_msg;
215  	   g_job_log.thread_name  := thread_name;
216  	   g_job_log.job_token	  := my_job_token;
217  	   g_job_log.logfile_name := logfile_name;
218  	   g_job_log.trace_level  := trace_level;
219  	   g_job_log.start_ts	  := current_timestamp;
220  	   g_job_log.log_level	  := log_level;
221  
222  	   set_trace(trace_level);
223  
224  	   my_tracefile_name := set_tracefile_identifier(g_job_log.job_log_id);
225  	   set_action('begin_job ' || to_char(g_job_log.job_log_id));
226  
227  
228  	end begin_log;
229  
230  	 --%~~~<
231    FUNCTION begin_job (
232  	 process_name in varchar,
233  	 log_set      in varchar default null,
234  	 classname    in varchar default null,
235  	 module_name  in varchar default null,
236  	 status_msg   in varchar default null,
237  	 thread_name  in varchar default null,
238  	 logfile_name	in varchar default null,
239  	 logfile_directory in varchar default 'JOB_MSG_DIR',
240  	 log_level    in pls_integer default G_INFO,
241  	 trace_level  in pls_integer default G_INFO)
242  	 return varchar
243  	--%>
244  	is
245  	  my_tracefile_name varchar(256);
246  	  my_job_token varchar(64) := get_job_token;
247  	  my_logfile_name varchar(64);
248  	begin
249  	  dbms_output.put_line('begin_job logfile_name "' || logfile_name);
250  
251  	  g_job_log.job_log_id := job_log_id_seq.nextval;
252  
253  	  if logfile_name is not null then
254  	    my_logfile_name := logfile_name;
255  	  else
256  	    my_logfile_name := my_job_token || '-' || g_job_log.job_log_id  ||
257  				    '.log';
258  	  end if;
259  
260  	  begin_log (
261  		 logfile_name	=> my_logfile_name,
262  		 logfile_directory => logfile_directory,
263  		 process_name => process_name,
264  		 log_set      => log_set,
265  		 classname    => classname,
266  		 module_name  => module_name,
267  		 status_msg   => status_msg,
268  		 thread_name  => thread_name,
269  		 log_level    => log_level,
270  		 trace_level  => trace_level
271  	  );
272  
273  	  set_action('begin_job ' || to_char(g_job_log.job_log_id));
274  	  job_log_insert ( g_job_log);
275  
276  	  return my_job_token;
277  	end begin_job;
278  
279  
280  
281    procedure end_job
282    --::* update job_log.status_id to 'C' and status_msg to 'DONE'
283    --::>
284    is
285  	    PRAGMA AUTONOMOUS_TRANSACTION;
286    begin
287  	    set_action('end_job');
288  	    update job_log
289  	    set
290  		   status_msg = 'DONE',
291  		   status_ts = SYSDATE
292  	     where job_log_id = g_job_log.job_log_id;
293  
294  	   commit;
295  	   set_action('end_job complete');
296    end end_job;
297  
298    procedure abort_job(
299  		     p_job_token     in varchar,
300  		     exception_msg in varchar default null,
301  		     stacktrace in varchar default null)
302    --::* procedure abort_job
303    --::* update job_log
304    --::* elapsed_time
305    --::* status_id = 'I'
306    --::* status_msg = 'ABORT'
307    --::>
308    is
309  	    PRAGMA AUTONOMOUS_TRANSACTION;
310  	    -- elapsed_tm   INTERVAL DAY TO SECOND;
311  	    stack   varchar (32767);
312    begin
313  	     set_action('abort_job');
314  	     -- g_process_end_tm := current_timestamp;
315  	     -- elapsed_tm := g_process_end_tm - g_process_start_tm;
316  
317  	     if stacktrace is not null then
318  		 stack := stacktrace;
319  	     else
320  		 stack := DBMS_UTILITY.format_call_stack ();
321  	     end if;
322  
323  	     update job_log
324  	     set
325  		  status_msg = 'ABORT',
326  		  status_ts = SYSDATE,
327  		  abort_stacktrace = stack
328  	     where job_token = p_job_token;
329  
330  	     COMMIT;
331  	     set_action('abort_job complete');
332    end abort_job;
333  
334    procedure set_debug(debug boolean default true)
335    is
336    begin
337  	     g_debug := debug;
338    end;
339  
340  
341    procedure set_action ( action in varchar ) is
342    begin
343  		 dbms_application_info.set_action(substr(action, 1, 64)) ;
344    end set_action ;
345  
346    procedure set_module ( module_name in varchar, action_name in varchar )
347    is
348    begin
349  		 dbms_application_info.set_module(module_name, action_name) ;
350    end set_module ;
351  
352    function open_log_file (
353  	     directory_name in varchar,
354  	     file_name in varchar,
355  	     headers in boolean default true)
356    return utl_file.file_type
357  	--
358  	--% opens a log file with the specified file name in the directory g_job_msg_dir
359    is
360  	   my_directory_path varchar2(4000);
361  	   my_handle utl_file.file_type;
362    begin
363  	   if (g_debug) then
364  	       dbms_output.put_line('open_log_file() dir: "' || directory_name ||
365  				'" file: "' || file_name || '"');
366  	   end if;
367  	   my_handle := utl_file.fopen(directory_name,file_name,'a');
368  	   return my_handle;
369    end open_log_file;
370  
371    function get_directory_path return varchar is
372  	    -- todo see if grants are wrong, permission must be granted to the user
373  	    cursor directory_cur is
374  	    select  owner, directory_name, directory_path
375  	    from    all_directories
376  	    where   directory_name = g_job_msg_dir;
377  
378  	    directory_rec directory_cur%rowtype;
379  
380    begin
381  	     open directory_cur;
382  	     fetch directory_cur into directory_rec;
383  	     dbms_output.put_line('owner: '	      || directory_rec.owner ||
384  				' directory_name: ' || directory_rec.directory_name ||
385  				' directory_path: ' || directory_rec.directory_path);
386  	    close directory_cur;
387  
388  	    return directory_rec.directory_path;
389    end get_directory_path;
390    --::<
391    function basename (full_path in varchar,
392  			  suffix    in varchar default null,
393  			  separator in char default '/')
394    return varchar
395  	   --:: like bash basename or gnu basename, returns the filename of a path optionally
396  	   --:: stripping the specified file extension
397  	   --::>
398    is
399  	    my_basename varchar(256);
400    begin
401  	     dbms_output.put_line('basename ' || full_path);
402  	     my_basename := substr(full_path, instr(full_path,separator,-1)+1);
403  	     dbms_output.put_line('my_basename' || my_basename);
404  	     if suffix is not null then
405  		 my_basename := substr(my_basename, 1, instr(my_basename, suffix, -1)-1);
406  	     end if;
407  
408  	    return my_basename;
409    end basename;
410  
411    function get_my_tracefile return clob is
412    begin
413  	  return get_tracefile(basename(get_my_tracefile_name));
414    end get_my_tracefile;
415  
416    function get_file(directory in varchar, file_name in varchar)
417    return clob is
418  	  my_clob	  clob;
419  	  my_bfile	  bfile;
420  	  my_dest_offset  integer := 1;
421  	  my_src_offset   integer := 1;
422  	  my_lang_context integer := dbms_lob.default_lang_ctx;
423  	  my_warning	  integer;
424    begin
425  	  my_bfile := bfilename(directory, file_name);
426  
427  	  dbms_lob.CreateTemporary(my_clob, FALSE, dbms_lob.CALL);
428  	  dbms_lob.FileOpen(my_bfile);
429  	  dbms_output.put_line('get_tracefile: before LoadClobFromFile');
430  
431  	  dbms_lob.LoadClobFromFile (
432  	    dest_lob	 => my_clob,
433  	    src_bfile	 => my_bfile,
434  	    amount	 => dbms_lob.lobmaxsize,
435  	    dest_offset  => my_dest_offset,
436  	    src_offset	 => my_src_offset,
437  	    bfile_csid	 => dbms_lob.default_csid,
438  	    lang_context => my_lang_context,
439  	    warning	 => my_warning
440  	  );
441  	  dbms_output.put_line('get_tracefile warning: ' || my_warning);
442  	  dbms_lob.FileClose(my_bfile);
443  
444  	  return my_clob;
445    end get_file;
446  
447    function get_tracefile(file_name in varchar)
448    return clob is
449    begin
450  	 return get_file('UDUMP_DIR',file_name);
451    end get_tracefile;
452  
453  /*
454    function get_tracefile(file_name in varchar)
455    return clob is
456  
457  	     my_clob	     clob;
458  	     my_bfile	     bfile;
459  	     my_dest_offset  integer := 1;
460  	     my_src_offset   integer := 1;
461  	     my_lang_context integer := dbms_lob.default_lang_ctx;
462  	     my_warning      integer;
463    begin
464  	     my_bfile := bfilename('UDUMP_DIR', file_name);
465  
466  	     dbms_lob.CreateTemporary(my_clob, FALSE, dbms_lob.CALL);
467  	     dbms_lob.FileOpen(my_bfile);
468  	     dbms_output.put_line('get_tracefile: before LoadClobFromFile');
469  
470  	     dbms_lob.LoadClobFromFile (
471  		 dest_lob     => my_clob,
472  		 src_bfile    => my_bfile,
473  		 amount       => dbms_lob.lobmaxsize,
474  		 dest_offset  => my_dest_offset,
475  		 src_offset   => my_src_offset,
476  		 bfile_csid   => dbms_lob.default_csid,
477  		 lang_context => my_lang_context,
478  		 warning      => my_warning
479  	     );
480  	     dbms_output.put_line('get_tracefile warning: ' || my_warning);
481  	     dbms_lob.FileClose(my_bfile);
482  
483  	     return my_clob;
484  	 end get_tracefile;
485    */
486  
487    procedure trace_step(step_name in varchar, job_step_id in number) is
488  	 my_job_step_id varchar(9) := to_char(job_step_id);
489  	 sql_text varchar(255) := 'select ''step_name: ''''' || step_name ||
490  		    ''''' job_log_id: ' || g_job_log.job_log_id ||
491  		   ' job_step_id: ' || my_job_step_id || ''' from dual';
492    begin
493  	 execute immediate sql_text;
494    end trace_step;
495  
496    procedure set_log_level (log_level in pls_integer) is
497  
498    begin
499  	 if    log_level < 1 then g_job_log.log_level := 1;
500  	 elsif log_level > 9 then g_job_log.log_level := 9;
501  	 else  g_job_log.log_level := log_level;
502  	 end if;
503    end set_log_level;
504  
505  
506    PROCEDURE prepare_connection is
507  	     context_info DBMS_SESSION.AppCtxTabTyp;
508  	     info_count   PLS_INTEGER;
509  	     indx	  PLS_INTEGER;
510    BEGIN
511  	     DBMS_SESSION.LIST_CONTEXT ( context_info, info_count);
512  	     indx := context_info.FIRST;
513  	     LOOP
514  		EXIT WHEN indx IS NULL;
515  		DBMS_SESSION.CLEAR_CONTEXT(
516  		    context_info(indx).namespace,
517  		    context_info(indx).attribute,
518  		   null
519  		 );
520  		indx := context_info.NEXT (indx);
521  	    END LOOP;
522  	    DBMS_SESSION.RESET_PACKAGE;
523    END prepare_connection;
524  
525    procedure logger_dtls_to_str is
526  	     ndx varchar(64);
527  	     dtl logger_dtl%rowtype;
528  	     retval long := '';
529    begin
530  	     --  dbms_output.put_line('logger_dtls_to_str');
531  	    -- dbms_output.put_line('about to get first');
532  	    -- ndx := logger_dtls.first();
533  	     -- dbms_output.put_line('ndx "' || ndx || '"');
534  
535  	     while ndx is not null loop
536  		 dtl :=  logger_dtls(ndx);
537  		 retval := retval || dtl.logger_nm  || ' ' || dtl.log_lvl || '\n';
538  		 ndx := logger_dtls.next(ndx);
539  	     end loop;
540  	     /*
541  	     if (g_debug ) then
542  		 dbms_output.put_line('>> ' || retval);
543  	     end if;
544  	     */
545  	    -- dbms_output.put_line('end logger_dtls_to_str');
546    end logger_dtls_to_str;
547  
548    function get_log_level (logger_name in varchar)
549    return number
550    is
551  	     my_logger_name varchar(64) := upper(logger_name);
552  	     my_log_dtl logger_dtl%rowtype;
553  	     retval number;
554  	     was_not varchar(9) := ' was ';
555    begin
556  	      logger_dtls_to_str;
557  	      if (g_debug) then dbms_output.put_line('get_log_level() my_logger_name: "' || my_logger_name || '"'); end if;
558  	      begin
559  		  my_log_dtl  := logger_dtls(my_logger_name);
560  		  if (g_debug) then dbms_output.put_line('get_log_level() my_dtl_log: "' || my_logger_name || '"'); end if;
561  		  retval := my_log_dtl.log_lvl;
562  	      exception
563  		 when no_data_found then
564  		   if g_job_log.log_level is null then
565  		       retval := g_info;
566  		   else
567  		       retval := g_job_log.log_level;
568  		   end if;
569  		   was_not := 'was not';
570  	      end;
571  
572  	     if (g_debug) then
573  		 dbms_output.put_line('get_log_level() ' ||
574  		     ' logger: "'  || logger_name || '" ' ||
575  		     was_not || ' found '  ||
576  		     ' level: '   || to_char(my_log_dtl.log_lvl) ||
577  		     ' retval: ' || to_char(retval));
578  	     end if;
579  	     return retval;
580  
581    end get_log_level;
582  
583    --
584    --  Logger hdr and dtl
585    --
586  
587    procedure create_set (set_nm    in varchar,
588  			     default_level     in number)
589    is
590    begin
591  	     insert into logger_hdr (logger_hdr_id, logger_set_nm, default_lvl)
592  	     values (logger_hdr_id_seq.nextval, upper(set_nm), default_level);
593    end create_set;
594  
595    procedure set_caller_level(name in varchar ,  level in pls_integer)
596    is
597  	     dtl  logger_dtl%rowtype;
598    begin
599  		 dtl.logger_nm := upper(name);
600  		 dtl.log_lvl := level;
601  		 logger_dtls(dtl.logger_nm) := dtl;
602    end;
603  
604    procedure define_logger_level(set_nm    in varchar,
605  			     logger_nm in varchar,
606  			     level     in number)
607    is
608  	     logger_rec logger_hdr%rowtype;
609    begin
610  
611  		  insert into logger_dtl (logger_dtl_id, logger_hdr_id,
612  			  logger_nm, log_lvl)
613  		  select logger_dtl_id_seq.nextval,
614  			 logger_hdr.logger_hdr_id,
615  			 upper(logger_nm), level
616  		  from	 logger_hdr
617  		  where
618  			logger_set_nm = upper(set_nm);
619  
620  		  exception when dup_val_on_index
621  		  then
622  		      update logger_dtl
623  		      set  log_lvl =  level
624  		      where logger_hdr_id =  (
625  			      select logger_hdr_id
626  			      from   logger_hdr
627  			      where logger_set_nm = upper(set_nm)
628  			     )
629  			      and logger_nm = upper(logger_nm);
630  
631  
632  
633    end define_logger_level;
634  
635    procedure log (
636  	   log_msg	in   varchar,
637  	   log_level	in   pls_integer default g_info,
638  	   dumstack   in   boolean default false
639    )
640    is
641  	   invalid_state_exception exception;
642  	   my_message	varchar2 (32767);
643  	   owner       varchar(64);
644  	   name        varchar(64);
645  	   line        number;
646  	   caller_type varchar(64);
647  	   my_logger_level number;
648  	   my_file_handle utl_file.file_type;
649  	   skip varchar(6) := ' skip ';
650    begin
651  	 OWA_UTIL.who_called_me (owner,name,line,caller_type);
652  	 if name is null then
653  		   name := 'anonymous';
654  	 end if;
655  	 my_logger_level := get_log_level(name);
656  
657  	 if (g_debug) and log_level > my_logger_level then
658  		 skip := '	';
659  		 dbms_output.put_line(
660  		   'log() ' ||	skip ||
661  		   'caller: ' || name ||
662  		   ' line: ' || line ||
663  		   ' my_logger_level: ' || to_char(my_logger_level) ||
664  		    ' log_level: '     || to_char(log_level));
665  	 end if;
666  
667  	   --dbms_output.put_line('logfile_name: ' || g_job_log.logfile_name);
668  
669  	 if log_level <= my_logger_level then
670  	   if g_job_log.logfile_name is not null then
671  	     -- write to file
672  	      my_message := logger_message_formatter  (
673  		job_log_id   => g_job_log.job_log_id,
674  		job_msg_id   => null,
675  		log_msg      => log_msg,
676  		log_level    => log_level,
677  		caller_name  => name,
678  		line_number  => line,
679  		separator    => ',',
680  		call_stack   => null
681  	      );
682  
683  	      my_file_handle := utl_file.fopen(g_job_log.directory_name,g_job_log.logfile_name,'a');
684  	      --my_file_handle := open_log_file (g_job_log.directory_name,g_job_log.logfile_name);
685  	      UTL_FILE.put_line (my_file_handle, my_message);
686  	      utl_file.fclose(my_file_handle);
687  	   else
688  	     raise invalid_state_exception;
689  	     my_message := logger_message_formatter  (
690  	       job_log_id   => g_job_log.job_log_id,
691  	       job_msg_id   => null,
692  	       log_msg	    => log_msg,
693  	       log_level    => log_level,
694  	       caller_name  => name,
695  	       line_number  => line,
696  	       separator    => ' ',
697  	       call_stack   => null
698  	       );
699  	       dbms_output.put_line (my_message);
700  	    end if;
701  	       --
702  	    if (g_debug) then
703  	      dbms_output.put_line('log(): ' || my_message);
704  	    end if;
705  	 end if;
706    end log;
707  
708  
709  begin dbms_output.ENABLE(1000000) ; -- set_context;
710  end logger;
711  --/>
712  
713  --#<
714  /

Package body created.

SQL> show errors
No errors.
SQL> --#>
SQL> describe job_step;
ERROR:
ORA-04043: object job_step does not exist 


SQL> exit
