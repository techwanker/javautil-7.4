SQL> CREATE OR REPLACE PACKAGE BODY pllogger
  2  is
  3     g_job_msg_dir    varchar2 (32) := 'JOB_MSG_DIR';
  4     g_job_msg_id     pls_integer;
  5     g_filter_level          pls_integer := G_INFO ;
  6     g_record_level          pls_integer := G_INFO ;
  7     g_file_handle           UTL_FILE.file_type;
  8     g_log_file_name         varchar2 (255);
  9     g_next_log_seq_nbr      pls_integer;
 10     g_dbms_output_level     pls_integer        := 5;
 11     g_process_start_tm      timestamp;
 12     g_process_end_tm        timestamp;
 13     g_process_name          varchar2 (128);
 14     g_job_id     pls_integer;
 15  -- set by get_caller
 16     g_owner_name            varchar2 (100);
 17     g_caller_name           varchar2 (100);
 18     g_line_number           pls_integer;
 19     g_caller_type           varchar2 (100);
 20  --
 21     g_sid                   pls_integer;
 22     g_current_schema        varchar2 (32);
 23     g_current_user          varchar2 (32);
 24     g_session_user          varchar2 (32);
 25     g_proxy_user            varchar2 (32);
 26     g_who_called_me_level   BINARY_integer     := 6;
 27     g_debug                 boolean := false;
 28     g_emit_headers          boolean := true;
 29     g_job_log          job_log%rowtype;
 30  
 31     g_logger_hdr logger_hdr%rowtype;
 32  
 33     /* https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites1.html */
 34  
 35     type logger_dtl_type is table of logger_dtl%rowtype index by varchar(64);
 36  
 37     logger_dtls logger_dtl_type;
 38  
 39     procedure set_trace (p_trace_level in pls_integer)
 40     is
 41     begin
 42        DBMS_TRACE.set_plsql_trace (p_trace_level);
 43     end set_trace;
 44  
 45     procedure set_job_token(p_job_token in varchar) is
 46     begin
 47         select * into g_job_log
 48         from job_log
 49         where job_token  = p_job_token;
 50      end;
 51  
 52      procedure  emit_header is
 53      begin
 54          if g_emit_headers then
 55              utl_file.put_line (g_file_handle, '"log_level","job_log_id","job_msg_id","line_number",' || 
 56                                                '"timestamp","log_msg","caller_name","call_stack"');
 57           end if;
 58      end emit_header;
 59  
 60     function open_log_file (
 61          p_file_name in varchar, 
 62          p_headers in boolean default true)
 63     return varchar
 64     --
 65     --% opens a log file with the specified file name in the directory g_job_msg_dir
 66     is
 67        my_log_file_name varchar(255);
 68        my_directory_path varchar2(4000);
 69     begin
 70        if (NOT UTL_FILE.is_open (g_file_handle))
 71        then
 72           -- TODO filter putlines 
 73           g_log_file_name := p_file_name;
 74           dbms_output.put_line('open_log_file  :>  directory "' || g_job_msg_dir || '" file "' || g_log_file_name || '"');
 75           g_file_handle := utl_file.fopen(g_job_msg_dir,g_log_file_name,'a');
 76           --utl_file.fclose(g_file_handle);
 77           --g_file_handle := utl_file.fopen(g_job_msg_dir,g_log_file_name,'a');
 78           emit_header;
 79  
 80        else
 81           dbms_output.put_line('open_log_file log_file is open: ' || g_log_file_name);
 82  
 83        end if;
 84        return my_log_file_name;
 85     end open_log_file;
 86  
 87     function get_g_job_id return number is
 88     begin
 89         if g_job_id  is  null then
 90             g_job_id := job_log_id_seq.nextval;
 91         end if;
 92         return g_job_id;
 93     end;
 94  
 95    /*
 96    procedure update_tracefile_name(p_tracefile_name in varchar) is
 97       pragma autonomous_transaction ;
 98    begin
 99  	  update job_log set tracefile_name = p_tracefile_name 
100  	  where job_log_id = g_job_id;
101  	  commit;
102    end;
103    */
104  
105      procedure use_logger_set(p_set_nm in varchar) 
106      is
107          no_such_logger_set exception;
108      begin
109         dbms_output.put_line('use_logger_set "' || p_set_nm || '"');
110         select * into g_logger_hdr from logger_hdr 
111         where logger_set_nm = upper(p_set_nm);
112  
113         exception when
114             no_data_found then raise_application_error(-200001,'no_such_logger_set ' || p_set_nm);
115  
116         for dtl in ( select * 
117         from logger_dtl
118         where logger_hdr_id = g_logger_hdr.logger_hdr_id)
119         loop
120             logger_dtls(upper(dtl.logger_nm)) := dtl;
121         end loop;
122      end;
123  
124      procedure logger_dtls_to_str is
125          ndx varchar(64);
126          dtl logger_dtl%rowtype;
127          retval long := '';
128      begin
129          dbms_output.put_line('logger_dtls_to_str');
130         -- dbms_output.put_line('about to get first');
131         -- ndx := logger_dtls.first();
132          -- dbms_output.put_line('ndx "' || ndx || '"');
133  
134          while ndx is not null loop
135              dtl :=  logger_dtls(ndx);
136              retval := retval || dtl.logger_nm  || ' ' || dtl.log_lvl || '\n';
137              ndx := logger_dtls.next(ndx);
138          end loop;
139          dbms_output.put_line('>> ' || retval);
140         -- dbms_output.put_line('end logger_dtls_to_str');
141      end logger_dtls_to_str;
142  
143      function get_log_level (p_logger_name in varchar) 
144      return number 
145      is 
146          my_logger_name varchar(64) := upper(p_logger_name);
147          my_log_dtl logger_dtl%rowtype;
148          retval number;
149      begin 
150           dbms_output.put_line('get_log_level()  p_logger_name *' || p_logger_name || ' my_logger_name *' || my_logger_name || '*');
151           logger_dtls_to_str;
152  
153           begin
154               my_log_dtl  := logger_dtls(my_logger_name);
155               retval := my_log_dtl.log_lvl;
156           exception 
157              when no_data_found then
158               dbms_output.put_line('logger not found ' || my_logger_name);
159               retval := g_filter_level;
160           end;
161  
162          dbms_output.put_line('get_log_level() ====> ' || p_logger_name || ' ' || to_char(my_log_dtl.log_lvl) || ' retval ' || to_char(retval));
163  
164          return retval;
165  
166      end get_log_level;
167    --::<
168    procedure create_process_log (
169        -- TODO no database updates, no commit or autonomous required
170  
171        p_job_log_id   in   pls_integer,
172        p_job_msg_id   in   pls_integer,
173        p_log_msg      in   varchar2,
174        p_log_level    in   pls_integer,
175        p_elapsed_time in   INTERVAL DAY TO SECOND DEFAULT NULL, -- TODO not recorded at this time
176        p_caller_name  in   varchar2,
177        p_line_number  in   pls_integer,
178        p_call_stack   in   varchar2 DEFAULT NULL
179     )
180     is
181        my_message   varchar2 (32767);
182        -- my_msg       varchar2 (32767);
183        now          timestamp        := SYSDATE;
184        --pragma autonomous_transaction ;
185        -- short_message varchar2(255);
186        -- long_message  clob;
187        my_log_file_name varchar2(4000);
188        my_logger_level number;
189  
190     begin
191         if p_caller_name is not null then  -- TODO make it work with null
192             my_logger_level := get_log_level(p_caller_name);
193          else
194             my_logger_level := g_filter_level;
195         end if;
196         g_next_log_seq_nbr := 1;
197  
198      /*
199        if g_log_file_name is NULL then  -- TODO name shoul be in one place
200           g_log_file_name := g_process_name || '_' || to_char (current_timestamp, 'YYYY-MM-DD_HH24MisSXFF');
201        end if;
202        */
203        my_log_file_name := open_log_file (g_job_log.logfile_name);  -- TODO why pass a global
204        g_next_log_seq_nbr := g_next_log_seq_nbr;        -- TODr + 1; O doesnt work with multitask
205        if g_debug then 
206          dbms_output.put_line('open_log_file' || g_log_file_name);
207          dbms_output.put_line('my_log_file_name: ' || my_log_file_name);
208          dbms_output.put_line('g_next_log_seq_nbr ' || g_next_log_seq_nbr);
209        end if;
210  
211        if p_log_level <= my_logger_level then
212            g_next_log_seq_nbr := g_next_log_seq_nbr + 1;   -- TODO this should go as too much work if multiple connections
213  
214            my_message := logger_message_formatter  (
215                job_log_id   => p_job_log_id,
216                job_msg_id   => p_job_msg_id,
217                log_msg      => p_log_msg,
218                log_level    => p_log_level,
219                caller_name  => p_caller_name,
220                line_number  => p_line_number,
221                call_stack   => p_call_stack
222            );
223       	  dbms_output.put_line('create_process_log about to write ' || to_char(p_log_level) || my_message); 
224       	  --dbms_output.put_line('p_caller_name ' || p_caller_name);
225       	  --dbms_output.put_line('p_line_number ' || p_line_number);
226      my_log_file_name := open_log_file (g_job_log.logfile_name); 
227            UTL_FILE.put_line (g_file_handle, my_message);
228            close_log_file;
229        else
230            dbms_output.put_line('create_process_log() skip p_log_level
231            ' || to_char(p_log_level) || ' my_logger_level ' 
232            || to_char(my_logger_level) || ' ' || my_message);
233  
234        end if;
235        -- commit;
236     end create_process_log;
237  
238     -- TODO bad name
239     --<
240     procedure TRACE (p_string in varchar2)
241     --% procedure TRACE (p_string in varchar2)
242     --% Write the messsage to dbms_output
243     -->
244     is
245     begin
246        dbms_output.put_line (p_string);
247     end TRACE;
248  
249  -- public
250     procedure set_dbms_output_level (p_level in pls_integer)
251     is
252     begin
253        g_dbms_output_level := p_level;
254     end set_dbms_output_level;
255  
256     procedure close_log_file
257     is
258     begin
259        if utl_file.is_open (g_file_handle) then
260            utl_file.fclose (g_file_handle);
261        end if;
262     end close_log_file;
263  
264     procedure log_level (
265        p_log_msg       in   varchar2,
266        p_log_level     in   pls_integer,
267        p_caller_name   in   varchar2 DEFAULT NULL,
268        p_line_number   in   pls_integer DEFAULT NULL,
269        p_call_stack    in   varchar2 DEFAULT NULL
270     )
271     is
272        log_time       timestamp  := current_timestamp;
273        elapsed        INTERVAL DAY TO SECOND;
274        my_log_level   pls_integer;
275     begin
276        my_log_level := p_log_level;
277  
278        if my_log_level < 1 then my_log_level := 1; end if;
279        if my_log_level > 9 then my_log_level := 9; end if;
280  
281        -- dbms_output.put_line('about to create process log');
282        --utl_file.put_line(g_file_handle, p_log_msg);  -- TODO
283        create_process_log (p_job_log_id  => g_job_id,
284                            p_job_msg_id            => g_job_log.job_log_id,
285                            p_log_msg               => p_log_msg,
286                            p_log_level             => my_log_level,
287                            p_elapsed_time          => elapsed,
288                            p_caller_name           => p_caller_name,
289                            p_line_number           => p_line_number,
290                            p_call_stack            => p_call_stack
291                           );
292     end log_level;
293  
294  
295     procedure LOG (p_level in pls_integer, p_log_msg IN varchar2)
296     is
297     begin
298        log_level (p_log_level        => p_level,
299                   p_log_msg          => p_log_msg,
300                   p_caller_name      => g_caller_name,
301                   p_line_number      => g_line_number
302                  );
303     end LOG;
304  
305     procedure severe (
306        p_unit           in   varchar2,
307        p_line           in   pls_integer,
308        p_log_msg        in   varchar2 DEFAULT '',
309        p_record_stack   in   BOOLEAN default false
310     )
311     is
312        stack   varchar2 (32767);
313     begin
314        if p_record_stack then
315           stack := DBMS_UTILITY.format_call_stack ();
316        end if;
317  
318        log_level (p_log_level        => g_severe,
319                   p_log_msg          => p_log_msg,
320                   p_caller_name      => p_unit,
321                   p_line_number      => p_line,
322                   p_call_stack       => stack
323                  );
324     end severe;
325  
326     procedure warning (
327        p_unit           in   varchar2,
328        p_line           in   pls_integer,
329        p_log_msg        in   varchar2,
330        p_record_stack   in   BOOLEAN
331     )
332     is
333        stack   varchar2 (32767);
334     begin
335        if p_record_stack then
336           stack := DBMS_UTILITY.format_call_stack ();
337        end if;
338  
339        log_level (p_log_level        => g_warning,
340                   p_log_msg          => p_log_msg,
341                   p_caller_name      => p_unit,
342                   p_line_number      => p_line,
343                   p_call_stack       => stack
344                  );
345     end warning;
346  
347  
348     procedure log_snap (
349        p_unit      in   varchar2,
350        p_line      in   pls_integer,
351        p_log_msg   in   varchar2
352     )
353     is
354     begin
355        OWA_UTIL.who_called_me (g_owner_name,
356                                g_caller_name,
357                                g_line_number,
358                                g_caller_type
359                               );
360  
361        log_level (p_log_level        => g_snap,
362                   p_log_msg          => p_log_msg,
363                   p_caller_name      => g_caller_name,
364                   p_line_number      => g_line_number
365                  );
366     end log_snap;
367  
368     procedure entering (
369        p_unit           in   varchar2,
370        p_line           in   pls_integer,
371        p_log_msg        in   varchar2 DEFAULT '',
372        p_record_stack   in   BOOLEAN DEFAULT FALSE,
373        p_set_action     in   BOOLEAN DEFAULT TRUE
374     )
375     is
376        stack   varchar2 (32767) := NULL;
377     begin
378        if p_record_stack then
379           stack := DBMS_UTILITY.format_call_stack ();
380        end if; 
381        log_level (p_log_level        => g_entering,
382                   p_log_msg          => p_log_msg,
383                   p_caller_name      => p_unit,
384                   p_line_number      => p_line,
385                   p_call_stack       => stack
386                  );
387        if p_set_action then dbms_application_info.set_action($$PLSQL_UNIT) ; end if;
388     end entering;
389  
390     procedure exiting (
391        p_unit           in   varchar2,
392        p_line           in   pls_integer,
393        p_log_msg        in   varchar2,
394        p_record_stack   in   BOOLEAN
395     )
396     is
397        stack   varchar2 (32767);
398     begin
399        if p_record_stack then
400           stack := DBMS_UTILITY.format_call_stack ();
401        end if;
402  
403        log_level (p_log_level        => g_exiting,
404                   p_log_msg          => p_log_msg,
405                   p_caller_name      => p_unit,
406                   p_line_number      => p_line,
407                   p_call_stack       => stack
408                  );
409        dbms_application_info.set_action('');
410     end exiting;
411  
412     procedure fine (
413        p_unit           in   varchar2,
414        p_line           in   pls_integer,
415        p_log_msg        in   varchar2,
416        p_record_stack   in   BOOLEAN
417     )
418     is
419        stack   varchar2 (32767);
420     begin
421        if p_record_stack then
422           stack := DBMS_UTILITY.format_call_stack ();
423        end if;
424  
425        log_level (p_log_level        => g_fine,
426                   p_log_msg          => p_log_msg,
427                   p_caller_name      => p_unit,
428                   p_line_number      => p_line,
429                   p_call_stack       => stack
430                  );
431     end fine;
432  
433     procedure finer (
434        p_unit           in   varchar2,
435        p_line           in   pls_integer,
436        p_log_msg        in   varchar2,
437        p_record_stack   in   BOOLEAN DEFAULT FALSE
438     )
439     is
440        stack   varchar2 (32767);
441     begin
442        if p_record_stack then 
443          stack := DBMS_UTILITY.format_call_stack (); 
444     end if;
445  
446        log_level (p_log_level        => g_finer,
447                   p_log_msg          => p_log_msg,
448                   p_caller_name      => p_unit,
449                   p_line_number      => p_line,
450                   p_call_stack       => stack
451                  );
452     end finer;
453  
454     procedure finest (
455        p_unit           in   varchar2,
456        p_line           in   pls_integer,
457        p_log_msg        in   varchar2,
458        p_record_stack   in   BOOLEAN DEFAULT FALSE
459     )
460     is
461        stack   varchar2 (32767);
462     begin
463        if p_record_stack then stack := DBMS_UTILITY.format_call_stack (); end if;
464  
465        log_level (p_log_level        => g_finest,
466                   p_log_msg          => p_log_msg,
467                   p_caller_name      => p_unit,
468                   p_line_number      => p_line,
469                   p_call_stack       => stack
470                  );
471     end finest;
472  
473     procedure LOG (
474        p_msg_id         in   varchar2,
475        p_log_msg        in   varchar2,
476        p_long_msg       in   varchar2,
477        p_elapsed_time   in   INTERVAL DAY TO SECOND DEFAULT NULL,
478        p_log_level      in   pls_integer,
479        p_call_stack     in   varchar2 DEFAULT NULL
480     )
481     is
482        my_log_time    timestamp ( 6 )        := current_timestamp;
483        my_elapsed     INTERVAL DAY TO SECOND;
484        my_log_level   pls_integer;
485     begin
486        my_log_level := p_log_level;
487  
488        if my_log_level < 1 then my_log_level := 1; end if;
489        if my_log_level > 9 then my_log_level := 9; end if;
490  
491        create_process_log (p_job_log_id   => g_job_id,
492                            p_job_msg_id              => p_msg_id,
493                            p_log_msg                 => p_log_msg,
494                            p_log_level               => my_log_level,
495                            p_elapsed_time            => my_elapsed,
496                            p_caller_name             => g_caller_name,
497                            p_line_number             => g_line_number,
498                            p_call_stack              => p_call_stack
499                           );
500     end LOG;
501  
502  
503     procedure set_filter_level (p_level in pls_integer)
504     is
505     begin
506        if    p_level < 1 then g_filter_level := 1;
507        elsif p_level > 9 then g_filter_level := 9;
508        else  g_filter_level := p_level; 
509        end if;
510     end set_filter_level;
511  
512     /**
513      procedure set_record_level (p_level in pls_integer)
514     */
515     procedure set_record_level (p_level in pls_integer)
516     is
517     begin
518        if    p_level < 1 then g_record_level := 1;
519        elsif p_level > 9 then g_record_level := 9;
520        else  g_record_level := p_level;
521        end if;
522     end set_record_level;
523  
524     function get_directory_path return varchar is
525        -- todo see if grants are wrong, permission must be granted to the user
526        cursor directory_cur is
527        select  owner, directory_name, directory_path
528        from    all_directories
529        where   directory_name = g_job_msg_dir;
530  
531        directory_rec directory_cur%rowtype;
532  
533      begin
534        open directory_cur;
535        fetch directory_cur into directory_rec;
536        dbms_output.put_line('owner: '           || directory_rec.owner ||
537                             ' directory_name: ' || directory_rec.directory_name ||
538                             ' directory_path: ' || directory_rec.directory_path);
539        close directory_cur;
540  
541        return directory_rec.directory_path;
542     end get_directory_path;
543  
544  
545    --::<
546    function basename (p_full_path in varchar2,
547                       p_suffix    in varchar2 default null,
548                       p_separator in char default '/')
549     return varchar2
550     --:: like bash basename or gnu basename, returns the filename of a path optionally
551     --:: stripping the specified file extension
552     --::>
553     is
554         my_basename varchar2(256);
555     begin
556         dbms_output.put_line('basename ' || p_full_path);
557         my_basename := substr(p_full_path, instr(p_full_path,p_separator,-1)+1);
558         dbms_output.put_line('my_basename' || my_basename);
559         if p_suffix is not null then
560            my_basename := substr(my_basename, 1, instr(my_basename, p_suffix, -1)-1);
561         end if;
562         return my_basename;
563     end basename;
564  
565     procedure log_msg (
566        p_log_msg        in   varchar,
567        p_level          in   pls_integer default G_INFO,
568        p_unit           in   varchar     default null,
569        p_line           in   pls_integer default null,
570        p_record_stack   in   BOOLEAN         -- record the call stack
571  
572     ) 
573     is 
574        stack   varchar2 (32767);
575     begin
576        if p_record_stack then
577          stack := dbms_utility.format_call_stack ();
578        end if;
579        log_level (p_log_level        => g_info,
580                   p_log_msg          => p_log_msg,
581                   p_caller_name      => p_unit,
582                   p_line_number      => p_line,
583                   p_call_stack       => stack
584                  );
585  
586     end log_msg;
587  
588  
589     procedure info (
590        p_unit           in   varchar2,       -- should be set with $$PLSQL_UNIT
591        p_line           in   pls_integer,    -- should be set with $$PLSQL_LINE
592        p_log_msg        in   varchar2,       -- the message to be logged
593        p_record_stack   in   BOOLEAN         -- record the call stack
594     )
595     is
596        stack   varchar2 (32767);
597     begin
598        if p_record_stack then
599          stack := dbms_utility.format_call_stack ();
600        end if;
601        log_level (p_log_level        => g_info,
602                   p_log_msg          => p_log_msg,
603                   p_caller_name      => p_unit,
604                   p_line_number      => p_line,
605                   p_call_stack       => stack
606                  );
607     end info;
608  
609      procedure set_action (p_action_name in varchar) is 
610      -- record the step name and then restore the action
611      -- the execute immediate makes sure the action is written to the trace file 
612      -- if there is no sql activity it is not written
613      begin
614         dbms_application_info.set_action(p_action_name);
615         execute immediate 'select ''' || p_action_name || ''' from dual'; -- TODO why 
616      end;
617  
618      procedure set_job_msg_id (p_job_msg_id in pls_integer) is
619      begin
620          g_job_msg_id := p_job_msg_id;
621      end;
622  
623    --
624    --  Logger hdr and dtl
625    --
626  
627      procedure create_set (p_set_nm    in varchar,
628                          p_default_level     in number)
629      is
630      begin
631          insert into logger_hdr (logger_hdr_id, logger_set_nm, default_lvl)
632          values (logger_hdr_id_seq.nextval, upper(p_set_nm), p_default_level);
633       end create_set;
634  
635      procedure define_logger_level(p_set_nm    in varchar,
636                          p_logger_nm in varchar,
637                          p_level     in number)
638      is 
639          logger_rec logger_hdr%rowtype;
640  
641      begin
642  
643               insert into logger_dtl (logger_dtl_id, logger_hdr_id, 
644                       logger_nm, log_lvl)
645               select logger_dtl_id_seq.nextval, 
646                      logger_hdr.logger_hdr_id,
647                      upper(p_logger_nm), p_level
648               from   logger_hdr 
649               where 
650                     logger_set_nm = upper(p_set_nm);
651  
652               exception when dup_val_on_index 
653               then
654                   update logger_dtl 
655                   set  log_lvl =  p_level
656                   where logger_hdr_id =  (
657                           select logger_hdr_id 
658                           from   logger_hdr
659                           where logger_set_nm = upper(p_set_nm) 
660  			)
661                           and logger_nm = upper(p_logger_nm);
662  
663  
664  
665      end define_logger_level;
666  
667  
668  
669  
670  begin
671     dbms_output.ENABLE(1000000) ;
672  end pllogger;
673  /

Package Body PLLOGGER compiled

SQL> --#<
SQL> show errors
SQL> --#>
