SQL> --#>
SQL> CREATE OR REPLACE PACKAGE BODY pllog
  2  is
  3  	 g_debug		 boolean := false;
  4  	 g_job_msg_dir		 varchar (32) := 'JOB_MSG_DIR';
  5  	 --g_file_handle	   UTL_FILE.file_type;
  6  	 g_logfile_name 	 varchar(255);
  7  
  8  
  9  	type logger_dtl_type is table of logger_dtl%rowtype index by varchar(64);
 10  
 11  	 logger_dtls logger_dtl_type;
 12  
 13  	 g_job_log job_log%rowtype;
 14  
 15  	 function format_time(p_timestamp in timestamp)
 16  	 return varchar
 17  	 is
 18  	     my_timestamp varchar(256) :=  to_char (current_timestamp, 'YYYY-MM-DD HH24:MI:SSXFF');
 19  	 begin
 20  	     my_timestamp := replace(my_timestamp,' ','T');
 21  	     -- dbms_output.put_line('format_time ' || my_timestamp);
 22  	     return my_timestamp;
 23  	 end format_time;
 24  
 25  	 function get_job_token
 26  	 return varchar
 27  	 is begin
 28  	     return format_time(current_timestamp);
 29  	 end;
 30  
 31  	 function get_new_job_log_id
 32  	 return number
 33  	 is begin
 34  	     return job_log_id_seq.nextval;
 35  	 end;
 36  
 37  	 --%#Tracing
 38  	 --%<
 39  	 procedure set_trace (p_trace_level in pls_integer)
 40  	 --%>
 41  	 is
 42  	 begin
 43  	    DBMS_TRACE.set_plsql_trace (p_trace_level);
 44  	 end set_trace;
 45  
 46  	 --%<
 47  	 function get_my_tracefile_name
 48  	 return varchar
 49  	 --%>
 50  	 is
 51  	      tracefile_name varchar(4096);
 52  	 begin
 53  	     select value into tracefile_name
 54  	     from v$diag_info
 55  	     where name = 'Default Trace File';
 56  
 57  	     return tracefile_name;
 58  	 end get_my_tracefile_name;
 59  
 60  	 --%<
 61  	 function set_tracefile_identifier(p_job_nbr in number)
 62  	 return varchar
 63  	 --%>
 64  	 is
 65  	    identifier varchar(32) := 'job_' || to_char(p_job_nbr);
 66  	 begin
 67  	     execute immediate 'alter session set tracefile_identifier = ''' || identifier || '''';
 68  	     return get_my_tracefile_name;
 69  	 end set_tracefile_identifier;
 70  
 71  
 72  
 73  	 procedure job_msg_insert (
 74  		    p_job_log_id in pls_integer,
 75  	 --	      g_next_log_seq_nbr in pls_integer,
 76  		    p_log_msg_id in varchar,
 77  		    p_short_message in varchar,
 78  		    p_log_level in pls_integer,
 79  		    p_caller_name in varchar,
 80  		    p_line_number in pls_integer,
 81  		    p_long_message in varchar
 82  	   )
 83  	is
 84  	    pragma autonomous_transaction ;
 85  	begin
 86  
 87  	   if p_log_level = g_snap OR p_log_level <= g_job_log.msg_lvl then
 88  	       insert into job_msg (
 89  		    job_msg_id,    job_log_id,
 90  		   -- log_seq_nbr,
 91  		    log_msg_id,
 92  		    log_msg,	   log_level,	      log_msg_ts,	   caller_name,
 93  		    line_nbr,	   log_msg_clob
 94  	       )
 95  	       values(
 96  		    p_log_msg_id,    p_job_log_id,
 97  		    -- g_next_log_seq_nbr,
 98  		    p_log_msg_id,
 99  		    p_short_message, p_log_level,     current_timestamp,   p_caller_name,
100  		    p_line_number,   p_long_message
101  	      );
102  	   end if;
103  	end;
104  
105  	 procedure job_log_insert(rec in job_log%rowtype) is
106  	 begin
107  	    insert into job_log (
108  	       job_log_id,     process_name,	thread_name,
109  	       status_msg,     status_ts,	tracefile_name,
110  	       classname,      schema_name,	module_name,
111  	       job_token,      logfile_name
112  	  ) values (
113  	       rec.job_log_id,	rec.process_name,   rec.thread_name,
114  	       rec.status_msg,	current_timestamp,  rec.tracefile_name,
115  	       rec.classname,	rec.schema_name,  rec.module_name,
116  	       rec.job_token,	rec.logfile_name
117  	);
118  
119  	 end;
120  
121  	procedure begin_log (
122  	     logfile_name   in varchar,
123  	     logfile_directory in varchar default 'JOB_MSG_DIR',
124  	     p_process_name in varchar default null,
125  	     p_log_set	    in varchar default null,
126  	     p_classname    in varchar default null,
127  	     p_module_name  in varchar default null,
128  	     p_status_msg   in varchar default null,
129  	     p_thread_name  in varchar default null,
130  	     p_log_level    in pls_integer default G_INFO,
131  	     p_trace_level  in pls_integer default G_INFO)
132  	 --%>
133  	 is
134  	     my_tracefile_name varchar(256);
135  	     my_job_token varchar(64) := format_time(current_timestamp);
136  
137  	 begin
138  	     dbms_output.put_line('begin_log() logfile_name "' || logfile_name || '"');
139  	     g_job_log.logfile_name := logfile_name;
140  	     g_job_log.directory_name := logfile_directory;
141  	     --g_job_log.job_log_id   := job_log_id_seq.nextval;
142  	     g_job_log.process_name := p_process_name;
143  	     g_job_log.classname    := p_classname;
144  	     g_job_log.module_name  := p_module_name;
145  	     g_job_log.status_msg   := p_status_msg;
146  	     g_job_log.thread_name  := p_thread_name;
147  	     g_job_log.job_token    := my_job_token;
148  	     g_job_log.logfile_name := logfile_name;
149  	     g_job_log.trace_level  := p_trace_level;
150  	     g_job_log.start_ts     := current_timestamp;
151  	     g_job_log.log_level    := p_log_level;
152  
153  	     set_trace(p_trace_level);
154  
155  	     my_tracefile_name := set_tracefile_identifier(g_job_log.job_log_id);
156  	     set_action('begin_job ' || to_char(g_job_log.job_log_id));
157  
158  
159  	 end begin_log;
160  
161  	 --%~~~<
162  	FUNCTION begin_job (
163  	     p_process_name in varchar,
164  	     p_log_set	    in varchar default null,
165  	     p_classname    in varchar default null,
166  	     p_module_name  in varchar default null,
167  	     p_status_msg   in varchar default null,
168  	     p_thread_name  in varchar default null,
169  	     logfile_name   in varchar default null,
170  	     logfile_directory in varchar default 'JOB_MSG_DIR',
171  	     p_log_level    in pls_integer default G_INFO,
172  	     p_trace_level  in pls_integer default G_INFO)
173  	     return varchar
174  	 --%>
175  	 is
176  	     my_tracefile_name varchar(256);
177  	     my_job_token varchar(64) := format_time(current_timestamp);
178  	     my_logfile_name varchar(64);
179  	 begin
180  	     dbms_output.put_line('begin_job logfile_name "' || logfile_name);
181  
182  	     g_job_log.job_log_id := job_log_id_seq.nextval;
183  
184  	     if logfile_name is not null then
185  		 my_logfile_name := logfile_name;
186  	     else
187  		 my_logfile_name := my_job_token || '-' || g_job_log.job_log_id  ||
188  				    '.log';
189  	     end if;
190  
191  	     begin_log (
192  		 logfile_name	=> my_logfile_name,
193  		 logfile_directory => logfile_directory,
194  		 p_process_name => p_process_name,
195  		 p_log_set	=> p_log_set,
196  		 p_classname	=> p_classname,
197  		 p_module_name	=> p_module_name,
198  		 p_status_msg	=> p_status_msg,
199  		 p_thread_name	=> p_thread_name,
200  		 p_log_level	=> p_log_level,
201  		 p_trace_level	=> p_trace_level
202  	     );
203  
204  	     set_action('begin_job ' || to_char(g_job_log.job_log_id));
205  	     job_log_insert ( g_job_log);
206  
207  	     return my_job_token;
208  	      end begin_job;
209  
210  
211  
212  	procedure end_job
213  	--::* update job_log.status_id to 'C' and status_msg to 'DONE'
214  	--::>
215  	is
216  	    PRAGMA AUTONOMOUS_TRANSACTION;
217  --       elapsed_tm   INTERVAL DAY TO SECOND;
218  	begin
219  	    set_action('end_job');
220   --      g_process_end_tm := current_timestamp;
221   --     elapsed_tm := g_process_end_tm - g_process_start_tm;
222  
223  	    update job_log
224  	    set
225  		   SID = NULL,
226  		   status_msg = 'DONE',
227  		   status_ts = SYSDATE
228  	     where job_log_id = g_job_log.job_log_id;
229  
230  	   commit;
231  	   set_action('end_job complete');
232  	end end_job;
233  
234  	 procedure abort_job(p_stacktrace in varchar default null)
235  	 --::* procedure abort_job
236  	 --::* update job_log
237  	 --::* elapsed_time
238  	 --::* status_id = 'I'
239  	 --::* status_msg = 'ABORT'
240  	 --::>
241  	 is
242  	    PRAGMA AUTONOMOUS_TRANSACTION;
243  	    -- elapsed_tm   INTERVAL DAY TO SECOND;
244  	    stack   varchar (32767);
245  	 begin
246  	     set_action('abort_job');
247  	     -- g_process_end_tm := current_timestamp;
248  	     -- elapsed_tm := g_process_end_tm - g_process_start_tm;
249  
250  	     if p_stacktrace is not null then
251  		 stack := p_stacktrace;
252  	     else
253  		 stack := DBMS_UTILITY.format_call_stack ();
254  	     end if;
255  
256  	     update job_log
257  	     set  SID = NULL,
258  		  status_msg = 'ABORT',
259  		  status_ts = SYSDATE,
260  		  abort_stacktrace = stack
261  	     where job_log_id = g_job_log.job_log_id;
262  
263  	     COMMIT;
264  	     set_action('abort_job complete');
265  	 end abort_job;
266  
267  	 procedure set_debug(debug boolean default true)
268  	 is
269  	 begin
270  	     g_debug := debug;
271  	 end;
272  
273  
274  	 procedure set_action ( p_action in varchar ) is
275  	 begin
276  		 dbms_application_info.set_action(substr(p_action, 1, 64)) ;
277  	 end set_action ;
278  
279  	 procedure set_module ( p_module_name in varchar, p_action_name in varchar )
280  	 is
281  	 begin
282  		 dbms_application_info.set_module(p_module_name, p_action_name) ;
283  	 end set_module ;
284  
285  	function open_log_file (
286  	     directory_name in varchar,
287  	     p_file_name in varchar,
288  	     p_headers in boolean default true)
289  	return utl_file.file_type
290  	--
291  	--% opens a log file with the specified file name in the directory g_job_msg_dir
292  	is
293  	   my_directory_path varchar2(4000);
294  	   my_handle utl_file.file_type;
295  	begin
296  	   if (g_debug) then
297  	       dbms_output.put_line('open_log_file() dir: "' || directory_name ||
298  				'" file: "' || p_file_name || '"');
299  	   end if;
300  	   my_handle := utl_file.fopen(directory_name,p_file_name,'a');
301  	   return my_handle;
302  	end open_log_file;
303  
304  	function get_directory_path return varchar is
305  	    -- todo see if grants are wrong, permission must be granted to the user
306  	    cursor directory_cur is
307  	    select  owner, directory_name, directory_path
308  	    from    all_directories
309  	    where   directory_name = g_job_msg_dir;
310  
311  	    directory_rec directory_cur%rowtype;
312  
313  	 begin
314  	     open directory_cur;
315  	     fetch directory_cur into directory_rec;
316  	     dbms_output.put_line('owner: '	      || directory_rec.owner ||
317  				' directory_name: ' || directory_rec.directory_name ||
318  				' directory_path: ' || directory_rec.directory_path);
319  	    close directory_cur;
320  
321  	    return directory_rec.directory_path;
322  	 end get_directory_path;
323    --::<
324  	   function basename (p_full_path in varchar,
325  			  p_suffix    in varchar default null,
326  			  p_separator in char default '/')
327  	   return varchar
328  	   --:: like bash basename or gnu basename, returns the filename of a path optionally
329  	   --:: stripping the specified file extension
330  	   --::>
331  	 is
332  	    my_basename varchar(256);
333  	 begin
334  	     dbms_output.put_line('basename ' || p_full_path);
335  	     my_basename := substr(p_full_path, instr(p_full_path,p_separator,-1)+1);
336  	     dbms_output.put_line('my_basename' || my_basename);
337  	     if p_suffix is not null then
338  		 my_basename := substr(my_basename, 1, instr(my_basename, p_suffix, -1)-1);
339  	     end if;
340  
341  	    return my_basename;
342  	 end basename;
343  
344  	 function get_my_tracefile return clob is
345  	 begin
346  	     return get_tracefile(basename(get_my_tracefile_name));
347  	 end get_my_tracefile;
348  
349  	 function get_tracefile(p_file_name in varchar)
350  	 return clob is
351  	     my_clob	     clob;
352  	     my_bfile	     bfile;
353  	     my_dest_offset  integer := 1;
354  	     my_src_offset   integer := 1;
355  	     my_lang_context integer := dbms_lob.default_lang_ctx;
356  	     my_warning      integer;
357  	 begin
358  	     my_bfile := bfilename('UDUMP_DIR', p_file_name);
359  
360  	     dbms_lob.CreateTemporary(my_clob, FALSE, dbms_lob.CALL);
361  	     dbms_lob.FileOpen(my_bfile);
362  	     dbms_output.put_line('get_tracefile: before LoadClobFromFile');
363  
364  	     dbms_lob.LoadClobFromFile (
365  		 dest_lob     => my_clob,
366  		 src_bfile    => my_bfile,
367  		 amount       => dbms_lob.lobmaxsize,
368  		 dest_offset  => my_dest_offset,
369  		 src_offset   => my_src_offset,
370  		 bfile_csid   => dbms_lob.default_csid,
371  		 lang_context => my_lang_context,
372  		 warning      => my_warning
373  	     );
374  	     dbms_output.put_line('get_tracefile warning: ' || my_warning);
375  	     dbms_lob.FileClose(my_bfile);
376  
377  	     return my_clob;
378  	 end get_tracefile;
379  
380  	 procedure trace_step(p_step_name in varchar, p_job_step_id in number) is
381  	    job_step_id varchar(9) := to_char(p_job_step_id);
382  	    sql_text varchar(255) := 'select ''step_name: ''''' || p_step_name ||
383  		    ''''' job_log_id: ' || g_job_log.job_log_id ||
384  		   ' job_step_id: ' || p_job_step_id || ''' from dual';
385  	 begin
386  	    execute immediate sql_text;
387  	 end;
388  
389  	 procedure set_log_level (p_level in pls_integer) is
390  	 begin
391  	     if    p_level < 1 then g_job_log.log_level := 1;
392  	     elsif p_level > 9 then g_job_log.log_level := 9;
393  	     else  g_job_log.log_level := p_level;
394  	     end if;
395  	 end set_log_level;
396  
397  
398  	 PROCEDURE prepare_connection is
399  	     context_info DBMS_SESSION.AppCtxTabTyp;
400  	     info_count   PLS_INTEGER;
401  	     indx	  PLS_INTEGER;
402  	 BEGIN
403  	     DBMS_SESSION.LIST_CONTEXT ( context_info, info_count);
404  	     indx := context_info.FIRST;
405  	     LOOP
406  		EXIT WHEN indx IS NULL;
407  		DBMS_SESSION.CLEAR_CONTEXT(
408  		    context_info(indx).namespace,
409  		    context_info(indx).attribute,
410  		   null
411  		 );
412  		indx := context_info.NEXT (indx);
413  	    END LOOP;
414  	    DBMS_SESSION.RESET_PACKAGE;
415  	 END prepare_connection;
416  
417  	 procedure logger_dtls_to_str is
418  	     ndx varchar(64);
419  	     dtl logger_dtl%rowtype;
420  	     retval long := '';
421  	 begin
422  	     --  dbms_output.put_line('logger_dtls_to_str');
423  	    -- dbms_output.put_line('about to get first');
424  	    -- ndx := logger_dtls.first();
425  	     -- dbms_output.put_line('ndx "' || ndx || '"');
426  
427  	     while ndx is not null loop
428  		 dtl :=  logger_dtls(ndx);
429  		 retval := retval || dtl.logger_nm  || ' ' || dtl.log_lvl || '\n';
430  		 ndx := logger_dtls.next(ndx);
431  	     end loop;
432  	     /*
433  	     if (g_debug ) then
434  		 dbms_output.put_line('>> ' || retval);
435  	     end if;
436  	     */
437  	    -- dbms_output.put_line('end logger_dtls_to_str');
438  	 end logger_dtls_to_str;
439  
440   function get_log_level (p_logger_name in varchar)
441  	 return number
442  	 is
443  	     my_logger_name varchar(64) := upper(p_logger_name);
444  	     my_log_dtl logger_dtl%rowtype;
445  	     retval number;
446  	     was_not varchar(9) := ' was ';
447  	 begin
448  	      logger_dtls_to_str;
449  	      if (g_debug) then dbms_output.put_line('get_log_level() my_logger_name: "' || my_logger_name || '"'); end if;
450  	      begin
451  		  my_log_dtl  := logger_dtls(my_logger_name);
452  		  if (g_debug) then dbms_output.put_line('get_log_level() my_dtl_log: "' || my_logger_name || '"'); end if;
453  		  retval := my_log_dtl.log_lvl;
454  	      exception
455  		 when no_data_found then
456  		   if g_job_log.log_level is null then
457  		       retval := g_info;
458  		   else
459  		       retval := g_job_log.log_level;
460  		   end if;
461  		   was_not := 'was not';
462  	      end;
463  
464  	     if (g_debug) then
465  		 dbms_output.put_line('get_log_level() ' ||
466  		     ' logger: "'  || p_logger_name || '" ' ||
467  		     was_not || ' found '  ||
468  		     ' level: '   || to_char(my_log_dtl.log_lvl) ||
469  		     ' retval: ' || to_char(retval));
470  	     end if;
471  	     return retval;
472  
473  	 end get_log_level;
474  
475    --
476    --  Logger hdr and dtl
477    --
478  
479  	 procedure create_set (p_set_nm    in varchar,
480  			     p_default_level	 in number)
481  	 is
482  	 begin
483  	     insert into logger_hdr (logger_hdr_id, logger_set_nm, default_lvl)
484  	     values (logger_hdr_id_seq.nextval, upper(p_set_nm), p_default_level);
485  	  end create_set;
486  
487  	 procedure set_caller_level(name in varchar ,  level in pls_integer)
488  	 is
489  	     dtl  logger_dtl%rowtype;
490  	 begin
491  		 dtl.logger_nm := upper(name);
492  		 dtl.log_lvl := level;
493  		 logger_dtls(dtl.logger_nm) := dtl;
494  	     end;
495  
496  	 procedure define_logger_level(p_set_nm    in varchar,
497  			     p_logger_nm in varchar,
498  			     p_level	 in number)
499  	 is
500  	     logger_rec logger_hdr%rowtype;
501  
502  	 begin
503  
504  		  insert into logger_dtl (logger_dtl_id, logger_hdr_id,
505  			  logger_nm, log_lvl)
506  		  select logger_dtl_id_seq.nextval,
507  			 logger_hdr.logger_hdr_id,
508  			 upper(p_logger_nm), p_level
509  		  from	 logger_hdr
510  		  where
511  			logger_set_nm = upper(p_set_nm);
512  
513  		  exception when dup_val_on_index
514  		  then
515  		      update logger_dtl
516  		      set  log_lvl =  p_level
517  		      where logger_hdr_id =  (
518  			      select logger_hdr_id
519  			      from   logger_hdr
520  			      where logger_set_nm = upper(p_set_nm)
521  			     )
522  			      and logger_nm = upper(p_logger_nm);
523  
524  
525  
526  	 end define_logger_level;
527  
528  
529  /*
530  	procedure log2(message in varchar,
531  		       level   in pls_integer default g_info)
532  	is
533  	   owner       varchar(64);
534  	   name        varchar(64);
535  	   line        number;
536  	   caller_type varchar(64);
537  	begin
538  	    OWA_UTIL.who_called_me (owner,name,line,caller_type);
539  	    --dbms_output.put_line('name: ' || name || ' line: ' || line);
540  	end log2;
541   */
542  
543    procedure log (
544  	   p_log_msg	  in   varchar,
545  	   p_log_level	  in   pls_integer default g_info,
546  	   p_dump_stack   in   boolean default false
547  	)
548  	is
549  	   my_message	varchar2 (32767);
550  	   owner       varchar(64);
551  	   name        varchar(64);
552  	   line        number;
553  	   caller_type varchar(64);
554  	   my_logger_level number;
555  	   my_file_handle utl_file.file_type;
556  	   skip varchar(6) := ' skip ';
557  	begin
558  	       OWA_UTIL.who_called_me (owner,name,line,caller_type);
559  	       if name is null then
560  		   name := 'anonymous';
561  	       end if;
562  	       my_logger_level := get_log_level(name);
563  
564  	   if (g_debug) and p_log_level > my_logger_level then
565  		 skip := '	';
566  		 dbms_output.put_line(
567  		   'log() ' ||	skip ||
568  		   'caller: ' || name ||
569  		   ' line: ' || line ||
570  		   ' my_logger_level: ' || to_char(my_logger_level) ||
571  		    ' p_log_level: '	 || to_char(p_log_level));
572  -- ||
573   --	 ' g_job_log.log_level: '     || to_char(g_job_log.log_level));
574  	   end if;
575  
576  	   if p_log_level <= my_logger_level then
577  	       my_message := logger_message_formatter  (
578  		   job_log_id	=> g_job_log.job_log_id,
579  		   job_msg_id	=> null,
580  		   log_msg	=> p_log_msg,
581  		   log_level	=> p_log_level,
582  		   caller_name	=> name,
583  		   line_number	=> line,
584  		   call_stack	=> null
585  	       );
586  	       -- write to file
587  	       my_file_handle := open_log_file (g_job_log.directory_name,g_job_log.logfile_name);
588  	       UTL_FILE.put_line (my_file_handle, my_message);
589  	       utl_file.fclose(my_file_handle);
590  	       --
591  	       if (g_debug) then
592  		  dbms_output.put_line('log(): ' || my_message);
593  	       end if;
594  	   end if;
595  	end log;
596  
597  
598  begin
599  	dbms_output.ENABLE(1000000) ;
600    -- set_context;
601  end pllog;
602  /

Package body created.

SQL> 
SQL> /*
SQL> begin
SQL> 	   sys.DBMS_MONITOR.session_trace_enable(waits=>TRUE, binds=>FALSE);
SQL> end;
SQL> /
SQL> */
SQL> --#<
SQL> show errors
No errors.
SQL> exit
