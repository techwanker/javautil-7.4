head	1.4;
access;
symbols;
locks
	jjs:1.4; strict;
comment	@# @;


1.4
date	2020.05.12.15.51.51;	author jjs;	state Exp;
branches;
next	1.3;

1.3
date	2020.05.12.03.48.28;	author jjs;	state Exp;
branches;
next	1.2;

1.2
date	2020.05.11.23.01.10;	author jjs;	state Exp;
branches;
next	1.1;

1.1
date	2020.04.26.05.12.02;	author jjs;	state Exp;
branches;
next	;


desc
@@


1.4
log
@*** empty log message ***
@
text
@--#<
set echo on 
--#>
CREATE OR REPLACE PACKAGE BODY logger
is
    g_job_msg_dir    varchar2 (32) := 'UT_PROCESS_LOG_DIR';
    g_filter_level          pls_integer := G_INFO ;
    g_record_level          pls_integer := G_INFO ;
    g_file_handle           UTL_FILE.file_type;
    g_log_file_name         varchar2 (255);
    g_last_log_seq_nbr      pls_integer;
    g_dbms_output_level     pls_integer        := 5;
    g_process_start_tm      timestamp;
    g_process_end_tm        timestamp;
    g_process_name          varchar2 (128);
    g_process_status_id     pls_integer;
 -- set by get_caller
    g_owner_name            varchar2 (100);
    g_caller_name           varchar2 (100);
    g_line_number           pls_integer;
    g_caller_type           varchar2 (100);
--
    g_sid                   pls_integer;
    g_current_schema        varchar2 (32);
    g_current_user          varchar2 (32);
    g_session_user          varchar2 (32);
    g_proxy_user            varchar2 (32);
    g_who_called_me_level   BINARY_integer     := 6;
--    g_job_log_id            pls_integer;


    function format_time(p_timestamp in timestamp)
    return varchar 
    is
	my_timestamp varchar(256) :=  to_char (current_timestamp, 'YYYY-MM-DD HH24:MI:SSXFF');
    begin
        my_timestamp := replace(my_timestamp,' ','T');
        return my_timestamp;
    end format_time;

    function get_new_job_log_id return number 
    is
    begin
        return job_log_id_seq.nextval;
    end;

    procedure set_trace (p_trace_level in pls_integer)
    is
    begin
       DBMS_TRACE.set_plsql_trace (p_trace_level);
    end set_trace;

    procedure job_msg_insert (
               p_job_log_id in pls_integer,
               g_next_log_seq_nbr in pls_integer,
               p_log_msg_id in varchar,
               p_short_message in varchar,
               p_log_level in pls_integer,
               p_caller_name in varchar,
               p_line_number in pls_integer,
               p_long_message in varchar
      )
   is
       pragma autonomous_transaction ;
   begin
    
      if p_log_level = g_snap OR p_log_level <= g_record_level then
          insert into job_msg (
               job_msg_id,    job_log_id,        log_seq_nbr,         log_msg_id,    
               log_msg,       log_level,         log_msg_ts,          caller_name,    
               line_nbr,      log_msg_clob
          )
          values(
               p_log_msg_id,    p_job_log_id,    g_next_log_seq_nbr,  p_log_msg_id,   
               p_short_message, p_log_level,     current_timestamp,   p_caller_name,
               p_line_number,   p_long_message
         );
      end if;
   end;

    function get_my_tracefile_name return varchar is
         tracefile_name varchar2(4096);
    begin
        select value into tracefile_name
        from v$diag_info
        where name = 'Default Trace File';

        return tracefile_name;
    end get_my_tracefile_name;

    function set_tracefile_identifier(p_job_nbr in number) return varchar is
       identifier varchar2(32) := 'job_' || to_char(p_job_nbr);
    begin
        execute immediate 'alter session set tracefile_identifier = ''' || identifier || '''';
        return get_my_tracefile_name;
    end set_tracefile_identifier;

--    procedure set_context
--    --% set sys_context userenv variables
--    is
--    begin
--/*
--        select SYS_CONTEXT ('USERENV', 'current_SCHEMA'),
--            SYS_CONTEXT ('USERENV', 'current_USER'),
--            SYS_CONTEXT ('USERENV', 'SESSION_USER'),
--            SYS_CONTEXT ('USERENV', 'PROXY_USER')
--        into g_current_schema,
--            g_current_user,
--            g_session_user,
--            g_proxy_user
--        from DUAL;
--*/
--        g_current_schema := SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');
--        g_current_user   := SYS_CONTEXT('USERENV', 'CURRENT_USER');
--        g_session_user   := SYS_CONTEXT('USERENV', 'SESSION_USER');
--        g_proxy_user     := SYS_CONTEXT('USERENV', 'PROXY_USER');
--    end set_context;


    procedure job_log_insert ( 
        p_job_log_id   in number,
        p_process_name in varchar,
        p_classname    in varchar,
        p_module_name  in varchar,
        p_status_msg   in varchar,
        p_thread_name  in varchar,
        p_job_token    in varchar,
        p_trace_level  in pls_integer default G_INFO) 
    is
        PRAGMA AUTONOMOUS_TRANSACTION;
        my_tracefile_name varchar(4096) := get_my_tracefile_name();
        my_current_schema varchar(32):= SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA');
        --g_current_user    := SYS_CONTEXT('USERENV', 'CURRENT_USER');
        --g_session_user    := SYS_CONTEXT('USERENV', 'SESSION_USER');
    begin
       -- TODO user etc
       insert into job_log (    
          job_log_id,     process_name,    thread_name,
          status_msg,     status_ts,       tracefile_name,
          classname,      schema_name,     module_name, 
          job_token
     ) values (
          p_job_log_id,  p_process_name,     p_thread_name,
          p_status_msg,  current_timestamp,  my_tracefile_name,
          p_classname,   my_current_schema,  p_module_name, 
          p_job_token
   );
   end job_log_insert;
  
    FUNCTION begin_job ( 
        p_process_name in varchar,
        p_logger_set   in varchar default null,
        p_classname    in varchar default null,
        p_module_name  in varchar default null,
        p_status_msg   in varchar default null,
        p_thread_name  in varchar default null,
        p_trace_level  in pls_integer default G_INFO)
        return varchar
    is
        my_tracefile_name varchar2(256);
        my_job_log_id number:= job_log_id_seq.nextval;
        my_job_token varchar(64) := format_time(current_timestamp);
    begin
        set_trace(p_trace_level);
        dbms_output.put_line('begin job ' || to_char(my_job_log_id));
        g_process_start_tm := current_timestamp;
        my_tracefile_name := set_tracefile_identifier(my_job_log_id);
        set_action('begin_job ' || to_char(my_job_log_id)); 
        g_log_file_name := my_job_token;

        job_log_insert ( 
            p_job_log_id   => my_job_log_id,
            p_process_name => p_process_name,
            p_classname    => p_classname,
            p_module_name   => p_module_name,
            p_status_msg   => p_status_msg,
            p_thread_name  => p_thread_name,
            p_trace_level  => p_trace_level,
            p_job_token    => my_job_token);
         
         return my_job_token;
    end begin_job;
   
 

   procedure end_job
   --::* update job_log.status_id to 'C' and status_msg to 'DONE'
   --::>
   is
       PRAGMA AUTONOMOUS_TRANSACTION;
       elapsed_tm   INTERVAL DAY TO SECOND;
   begin
       set_action('end_job');
       g_process_end_tm := current_timestamp;
       elapsed_tm := g_process_end_tm - g_process_start_tm;

       update job_log
       set
              SID = NULL,
              status_msg = 'DONE',
              status_ts = SYSDATE
       where job_log_id = g_process_status_id;

      commit;
      set_action('end_job complete');
   end end_job;
   
    procedure abort_job(p_stacktrace in varchar default null)
    --::* procedure abort_job
    --::* update job_log
    --::* elapsed_time
    --::* status_id = 'I'
    --::* status_msg = 'ABORT'
    --::>
    is
       PRAGMA AUTONOMOUS_TRANSACTION;
       elapsed_tm   INTERVAL DAY TO SECOND;
       stack   varchar2 (32767);
    begin
        set_action('abort_job');
        g_process_end_tm := current_timestamp;
        elapsed_tm := g_process_end_tm - g_process_start_tm;
      
        if p_stacktrace is not null then
            stack := p_stacktrace;
        else
            stack := DBMS_UTILITY.format_call_stack ();
        end if;

        update job_log
        set  SID = NULL,
             status_msg = 'ABORT',
             status_ts = SYSDATE,
             abort_stacktrace = stack
        where job_log_id = g_process_status_id;

        COMMIT;
        set_action('abort_job complete');
    end abort_job;


    procedure set_action ( p_action in varchar2 ) is
    begin
            dbms_application_info.set_action(substr(p_action, 1, 64)) ;
    end set_action ;

    procedure set_module ( p_module_name in varchar, p_action_name in varchar )
    is
    begin
            dbms_application_info.set_module(p_module_name, p_action_name) ;
    end set_module ;


   function get_directory_path return varchar is
       -- todo see if grants are wrong, permission must be granted to the user
       cursor directory_cur is
       select  owner, directory_name, directory_path
       from    all_directories
       where   directory_name = g_job_msg_dir;
 
       directory_rec directory_cur%rowtype;

    begin
        open directory_cur;
        fetch directory_cur into directory_rec;
        dbms_output.put_line('owner: '           || directory_rec.owner ||
                           ' directory_name: ' || directory_rec.directory_name ||
                           ' directory_path: ' || directory_rec.directory_path);
       close directory_cur;

       return directory_rec.directory_path;
    end get_directory_path;
  --::<
      function basename (p_full_path in varchar2,
                     p_suffix    in varchar2 default null,
                     p_separator in char default '/')
      return varchar2
      --:: like bash basename or gnu basename, returns the filename of a path optionally
      --:: stripping the specified file extension
      --::>
    is
       my_basename varchar2(256);
    begin
        dbms_output.put_line('basename ' || p_full_path);
        my_basename := substr(p_full_path, instr(p_full_path,p_separator,-1)+1);
        dbms_output.put_line('my_basename' || my_basename);
        if p_suffix is not null then
            my_basename := substr(my_basename, 1, instr(my_basename, p_suffix, -1)-1);
        end if;

       return my_basename;
    end basename;
  
    function get_my_tracefile return clob is
    begin
        return get_tracefile(basename(get_my_tracefile_name));
    end get_my_tracefile;

    function get_tracefile(p_file_name in varchar)
    return clob is
        my_clob         clob;
        my_bfile        bfile;
        my_dest_offset  integer := 1;
        my_src_offset   integer := 1;
        my_lang_context integer := dbms_lob.default_lang_ctx;
        my_warning      integer;
    begin
        my_bfile := bfilename('UDUMP_DIR', p_file_name);

        dbms_lob.CreateTemporary(my_clob, FALSE, dbms_lob.CALL);
        dbms_lob.FileOpen(my_bfile);
        dbms_output.put_line('get_tracefile: before LoadClobFromFile');

        dbms_lob.LoadClobFromFile (
            dest_lob     => my_clob,
            src_bfile    => my_bfile,
            amount       => dbms_lob.lobmaxsize,
            dest_offset  => my_dest_offset,
            src_offset   => my_src_offset,
            bfile_csid   => dbms_lob.default_csid,
            lang_context => my_lang_context,
            warning      => my_warning
        );
        dbms_output.put_line('get_tracefile warning: ' || my_warning);
        dbms_lob.FileClose(my_bfile);

        return my_clob;
    end get_tracefile;

    procedure trace_step(p_step_name in varchar, p_job_step_id in number) is
       job_step_id varchar(9) := to_char(p_job_step_id);
       sql_text varchar(255) := 'select ''step_name: ''''' || p_step_name || 
               ''''' job_log_id: ' || g_process_status_id || 
              ' job_step_id: ' || p_job_step_id || ''' from dual';
    begin
     --  dbms_output.put_line(sql_text);
       execute immediate sql_text;
    end;

    procedure set_filter_level (p_level in pls_integer) is
    begin
        if    p_level < 1 then g_filter_level := 1;
        elsif p_level > 9 then g_filter_level := 9;
        else  g_filter_level := p_level;
        end if;
    end set_filter_level;


    PROCEDURE prepare_connection is
        context_info DBMS_SESSION.AppCtxTabTyp;
        info_count   PLS_INTEGER;
        indx         PLS_INTEGER;
    BEGIN
        DBMS_SESSION.LIST_CONTEXT ( context_info, info_count);
        indx := context_info.FIRST;
        LOOP
           EXIT WHEN indx IS NULL;
           DBMS_SESSION.CLEAR_CONTEXT(
               context_info(indx).namespace,
               context_info(indx).attribute,
              null
            );
           indx := context_info.NEXT (indx);
       END LOOP;
       DBMS_SESSION.RESET_PACKAGE;
    END prepare_connection;




begin
   dbms_output.ENABLE(1000000) ;
  -- set_context;
end logger;
/

begin
      sys.DBMS_MONITOR.session_trace_enable(waits=>TRUE, binds=>FALSE);
end;
/
--#<
show errors
--#>
@


1.3
log
@*** empty log message ***
@
text
@d6 16
a21 16
   g_job_msg_dir    varchar2 (32) := 'UT_PROCESS_LOG_DIR';
   g_filter_level          pls_integer := G_INFO ;
   g_record_level          pls_integer := G_INFO ;
   g_file_handle           UTL_FILE.file_type;
   g_log_file_name         varchar2 (255);
   g_last_log_seq_nbr      pls_integer;
   g_dbms_output_level     pls_integer        := 5;
   g_process_start_tm      timestamp;
   g_process_end_tm        timestamp;
   g_process_name          varchar2 (128);
   g_process_status_id     pls_integer;
-- set by get_caller
   g_owner_name            varchar2 (100);
   g_caller_name           varchar2 (100);
   g_line_number           pls_integer;
   g_caller_type           varchar2 (100);
d23 7
a29 7
   g_sid                   pls_integer;
   g_current_schema        varchar2 (32);
   g_current_user          varchar2 (32);
   g_session_user          varchar2 (32);
   g_proxy_user            varchar2 (32);
   g_who_called_me_level   BINARY_integer     := 6;
   g_job_log_id            pls_integer;
a30 6
   procedure set_trace (p_trace_level in pls_integer)
   is
   begin
      DBMS_TRACE.set_plsql_trace (p_trace_level);
   end set_trace;
   
d32 8
a39 16
--   function get_g_process_status_id return number is
--   begin
--       if g_process_status_id  is  null then
--           g_process_status_id := job_log_id_seq.nextval;
--       end if;
--       return g_process_status_id;
--   end;
--
--  procedure update_tracefile_name(p_tracefile_name in varchar) is
--     pragma autonomous_transaction ;
--  begin
--	  update job_log set tracefile_name = p_tracefile_name 
--	  where job_log_id = g_process_status_id;
--	  commit;
--  end;
---4---8---*
d41 5
d47 5
d53 1
a53 1
 procedure job_msg_insert (
d64 1
a64 1
      pragma autonomous_transaction ;
d81 1
a81 1
function get_my_tracefile_name return varchar is
d83 3
a85 3
   begin
       select value into tracefile_name
       from v$diag_info
d88 2
a89 2
       return tracefile_name;
   end get_my_tracefile_name;
d91 1
a91 1
   function set_tracefile_identifier(p_job_nbr in number) return varchar is
d93 1
a93 1
   begin
d96 23
a118 1
   end set_tracefile_identifier;
d120 9
a128 2
    procedure set_context
   --% set sys_context userenv variables
d130 5
d136 13
a148 37
        select SYS_CONTEXT ('USERENV', 'current_SCHEMA'),
            SYS_CONTEXT ('USERENV', 'current_USER'),
            SYS_CONTEXT ('USERENV', 'SESSION_USER'),
            SYS_CONTEXT ('USERENV', 'PROXY_USER')
        into g_current_schema,
            g_current_user,
            g_session_user,
            g_proxy_user
        from DUAL;
    end set_context;

    procedure save_job_log (
        p_job_log_id   in number,
   		p_schema_name  in varchar2,
    	p_process_name in varchar2,
        p_classname    in varchar2,
        p_module_name  in varchar2,
        p_status_msg   in varchar2,
        p_thread_name  in varchar2,
        p_trace_level  in pls_integer default G_INFO,
        p_tracefile_name in varchar2,
        p_sid          in pls_integer
    ) is
    pragma autonomous_transaction ;                
    begin  
        insert into job_log (
          job_log_id,   schema_name, process_name, thread_name,        
          status_msg, status_ts,   sid,          module_name,
          classname,   tracefile_name
   
        ) values (
          p_job_log_id,  p_schema_name, p_process_name,  p_thread_name, 
          p_status_msg,    systimestamp,  p_sid,         p_module_name,
          p_classname,    p_tracefile_name
        );
        commit;
   end save_job_log;
d150 9
a158 35
/* 
   function save_job_step (
        p_job_log_id  in pls_integer, 
        p_step_name   in varchar, 
        p_step_info   in varchar, 
        p_classname   in varchar,     
        p_start_ts    in timestamp,
        p_stacktrace  in varchar
   ) return number
   is begin
	   insert into job_step (
        job_step_id,   job_log_id, step_name, step_info, 
        classname,     start_ts,   stacktrace
      ) values (
        job_step_id_seq.nextval, :p_job_log_id, :p_step_name,:p_step_info, 
        :p_classname,   :p_start_ts,   :p_stacktrace
      ) returning job_step_id into g_job_step_id;
      return g_job_step_id;
      
   end save_job_step;
   
    procedure finish_step is 
    begin
       update job_step 
       set end_ts = systimestamp
       where job_step_id = g_job_step_id;
    end finish_step;
*/
/*
    function begin_job(
        p_module_name in varchar,
        p_job_log_id  in number  default null,
        p_action_name in varchar default 'begin',
        p_trace_level in integer default G_INFO)
    return varchar
d160 3
a162 2
      my_tracefile_name varchar2(256);
      my_job_log_id number := p_job_log_id;
d164 18
a181 14
      -- g_job_log_id := p_job_log_id;
      if p_job_log_id is null
      then
          select job_log_id_seq.nextval
          into my_job_log_id
          from dual;
      end if;
      set_trace(p_trace_level);
      dbms_output.put_line('begin java job ' || to_char(g_job_log_id));
      g_process_start_tm := current_timestamp;
      my_tracefile_name := set_tracefile_identifier(p_job_log_id);
      set_action('begin_job ' || to_char(g_job_log_id)); 
      dbms_output.put_line('logger begin_job returning ' || my_tracefile_name);
      return my_tracefile_name;
a182 35
     */
    FUNCTION begin_job ( 
       p_process_name in varchar,
       p_classname   in varchar default null,
       p_module_name  in varchar default null,
       p_status_msg   in varchar default null,
       p_thread_name  in varchar default null,
       p_trace_level  in pls_integer default G_INFO)
       return varchar
   is
      my_tracefile_name varchar2(256);
      my_job_log_id number:= job_log_id_seq.nextval;
      my_job_token varchar(64) := format_time(current_timestamp);
   begin
      --sys.DBMS_MONITOR.session_trace_enable(waits=>TRUE, binds=>FALSE);

      
      set_trace(p_trace_level);
      dbms_output.put_line('begin job ' || to_char(g_job_log_id));
      g_process_start_tm := current_timestamp;
      my_tracefile_name := set_tracefile_identifier(p_job_log_id);
      set_action('begin_job ' || to_char(my_job_log_id)); 
      
     job_log_insert ( 
         p_job_log_id   => my_job_log_id,
         p_process_name => p_process_name,
         p_classname    => p_classname,
         p_module_name  => p_module_name,
         p_status_msg   => p_status_msg.
         p_thread_name  => p_thread_name
         p_trace_level  => p_trace_level,
         p_job_token    => my_job_token);
         
      return my_job_token;
   end begin_job;
a184 26
   procedure job_log_insert ( 
    p_job_log_id   in number,
    p_process_name in varchar,
    p_classname    in varchar,
    p_module_name  in varchar,
    p_status_msg   in varchar,
    p_thread_name  in varchar,
    p_job_token    in varchar,
    p_trace_level  in pls_integer default G_INFO) 
   is
      PRAGMA AUTONOMOUS_TRANSACTION;
      my_tracefile_name varchar(4096) := get_my_tracefile_name();
   begin
     insert into job_log (    
          job_log_id,     process_name,    thread_name,
          status_msg,     status_ts,       tracefile_name,
          classname,      
--          schema_name,     
          module_name, job_token
     ) values (
          p_job_log_id,  p_process_name, p_thread_name,
          p_status_msg,  current_timestamp,  my_tracefile_name ,
          p_classname,   
            --p_schema_name,  
         p_module_name, my_job_token
   end job_log_insert;
d208 21
a228 21
   procedure abort_job(p_stacktrace in varchar default null)
   --::* procedure abort_job
   --::* update job_log
   --::* elapsed_time
   --::* status_id = 'I'
   --::* status_msg = 'ABORT'
   --::>
   is
      PRAGMA AUTONOMOUS_TRANSACTION;
      elapsed_tm   INTERVAL DAY TO SECOND;
     stack   varchar2 (32767);
   begin
      set_action('abort_job');
      g_process_end_tm := current_timestamp;
      elapsed_tm := g_process_end_tm - g_process_start_tm;
     
      if p_stacktrace is not null then
         stack := p_stacktrace;
      else
         stack := DBMS_UTILITY.format_call_stack ();
      end if;
d230 2
a231 3
      update job_log
      set
             SID = NULL,
d235 1
a235 1
       where job_log_id = g_process_status_id;
d237 3
a239 3
      COMMIT;
      set_action('abort_job complete');
   end abort_job;
d255 7
a261 7
      -- todo see if grants are wrong, permission must be granted to the user
      cursor directory_cur is
      select  owner, directory_name, directory_path
      from    all_directories
      where   directory_name = g_job_msg_dir;

      directory_rec directory_cur%rowtype;
d264 3
a266 3
      open directory_cur;
      fetch directory_cur into directory_rec;
      dbms_output.put_line('owner: '           || directory_rec.owner ||
d269 1
a269 4
      close directory_cur;

      return directory_rec.directory_path;
   end get_directory_path;
d271 2
d274 1
a274 1
  function basename (p_full_path in varchar2,
d277 5
a281 5
   return varchar2
   --:: like bash basename or gnu basename, returns the filename of a path optionally
   --:: stripping the specified file extension
   --::>
   is
d283 7
a289 7
   begin
       dbms_output.put_line('basename ' || p_full_path);
       my_basename := substr(p_full_path, instr(p_full_path,p_separator,-1)+1);
       dbms_output.put_line('my_basename' || my_basename);
       if p_suffix is not null then
          my_basename := substr(my_basename, 1, instr(my_basename, p_suffix, -1)-1);
       end if;
d292 2
a293 2
   end basename;

d332 3
a334 1
       sql_text varchar(255) := 'select ''step_name: ''''' || p_step_name || ''''' job_log_id: ' || g_process_status_id || ' job_step_id: ' || p_job_step_id || ''' from dual';
d340 7
a346 7
   procedure set_filter_level (p_level in pls_integer) is
   begin
      if    p_level < 1 then g_filter_level := 1;
      elsif p_level > 9 then g_filter_level := 9;
      else  g_filter_level := p_level;
      end if;
   end set_filter_level;
d350 3
a352 3
       context_info DBMS_SESSION.AppCtxTabTyp;
       info_count   PLS_INTEGER;
       indx         PLS_INTEGER;
d354 10
a363 10
       DBMS_SESSION.LIST_CONTEXT ( context_info, info_count);
       indx := context_info.FIRST;
       LOOP
          EXIT WHEN indx IS NULL;
          DBMS_SESSION.CLEAR_CONTEXT(
             context_info(indx).namespace,
             context_info(indx).attribute,
             null
          );
          indx := context_info.NEXT (indx);
d373 1
a373 1
   set_context;
@


1.2
log
@*** empty log message ***
@
text
@d172 1
a172 1

d198 7
a204 8
     
    FUNCTION begin_java_job ( 
       p_job_log_id   in number,
       p_process_name in varchar2,
       p_classname   in varchar2,
       p_module_name  in varchar2,
       p_status_msg   in varchar2,
       p_thread_name  in varchar2,
d209 2
d214 1
a214 1
      g_job_log_id := p_job_log_id;
d216 1
a216 1
      dbms_output.put_line('begin java job ' || to_char(g_job_log_id));
d219 14
a232 3
      set_action('begin_java_job ' || to_char(g_job_log_id)); 
      return my_tracefile_name;
   end begin_java_job;
d235 1
a235 1
   procedure persist_job_log ( 
d242 1
d253 1
a253 1
          module_name
d259 2
a260 2
         p_module_name);
   end persist_job_log;
@


1.1
log
@Initial revision
@
text
@d195 1
d271 1
a271 1
   procedure abort_job(p_stacktrace in varchar)
d281 1
d286 6
d298 1
a298 1
             abort_stacktrace = p_stacktrace
a299 1

@
