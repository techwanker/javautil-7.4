head	1.1;
access;
symbols;
locks
	jjs:1.1; strict;
comment	@# @;


1.1
date	2020.05.11.23.01.10;	author jjs;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@SQL> CREATE OR REPLACE PACKAGE BODY pllogger
  2  is
  3     g_job_msg_dir    varchar2 (32) := 'JOB_MSG_DIR';
  4     g_job_msg_id     pls_integer;
  5     g_filter_level          pls_integer := G_INFO ;
  6     g_record_level          pls_integer := G_INFO ;
  7     g_file_handle           UTL_FILE.file_type;
  8     g_log_file_name         varchar2 (255);
  9     g_next_log_seq_nbr      pls_integer;
 10     g_dbms_output_level     pls_integer        := 5;
 11     g_process_start_tm      timestamp;
 12     g_process_end_tm        timestamp;
 13     g_process_name          varchar2 (128);
 14   --  g_job_id     pls_integer;
 15  -- set by get_caller
 16     g_owner_name            varchar2 (100);
 17     g_caller_name           varchar2 (100);
 18     g_line_number           pls_integer;
 19     g_caller_type           varchar2 (100);
 20  --
 21     g_sid                   pls_integer;
 22     g_current_schema        varchar2 (32);
 23     g_current_user          varchar2 (32);
 24     g_session_user          varchar2 (32);
 25     g_proxy_user            varchar2 (32);
 26     g_who_called_me_level   BINARY_integer     := 6;
 27     g_debug                 boolean := false;
 28     g_emit_headers          boolean := true;
 29     g_job_log               job_log%rowtype;
 30  
 31  
 32     g_logger_hdr logger_hdr%rowtype;
 33  
 34     /* https://livesql.oracle.com/apex/livesql/docs/lnpls/plsql-collections-and-records/composites1.html */
 35  
 36     type logger_dtl_type is table of logger_dtl%rowtype index by varchar(64);
 37  
 38     logger_dtls logger_dtl_type;
 39  
 40     procedure set_job_token(p_job_token in varchar) is
 41     begin
 42        select * into g_job_log 
 43        from  job_log
 44        where job_token = p_job_token;
 45        g_log_file_name := g_job_log.logfile_name;
 46      end;
 47  
 48  
 49     procedure set_trace (p_trace_level in pls_integer)
 50     is
 51     begin
 52        DBMS_TRACE.set_plsql_trace (p_trace_level);
 53     end set_trace;
 54  
 55      procedure  emit_header is
 56      begin
 57          if g_emit_headers then
 58              utl_file.put_line (g_file_handle, '"log_level","job_log_id","job_msg_id","line_number","timestamp","log_msg","caller_name","call_stack"');
 59           end if;
 60      end emit_header;
 61  
 62     function open_log_file (
 63          p_file_name in varchar, 
 64          p_headers in boolean default true)
 65        --  p_job_log_id in pls_integer default null) 
 66     return varchar
 67     --
 68     --% opens a log file with the specified file name in the directory g_job_msg_dir
 69     is
 70        my_log_file_name varchar(255) := '';
 71        my_directory_path varchar2(4000);
 72     begin
 73        if (NOT UTL_FILE.is_open (g_file_handle))
 74        then
 75          -- if g_job_id is null then
 76          --    g_job_id := job_log_id_seq.nextval;
 77          --  end if;
 78          /*
 79           if p_file_name is not null then
 80              my_log_file_name := p_file_name;
 81           end if;
 82           if p_job_log_id is not null then
 83              my_log_file_name := my_log_file_name || '_job_' || to_char(g_job_id);
 84           end if;
 85          */
 86           -- TODO filter putlines 
 87           dbms_output.put_line('open_log_file:> ' || g_job_msg_dir || ' ' || my_log_file_name);
 88      --  g_log_file_name := my_log_file_name;
 89           g_file_handle := utl_file.fopen(g_job_msg_dir,g_log_file_name,'a');
 90         --  utl_file.fclose(g_file_handle);
 91        --   g_file_handle := utl_file.fopen(g_job_msg_dir,g_log_file_name,'a');
 92           emit_header;
 93  
 94        else
 95           dbms_output.put_line('open_log_file log_file is open: ' || g_log_file_name);
 96  
 97        end if;
 98        return my_log_file_name;
 99     end open_log_file;
100  /*
101     function get_g_job_id return number is
102     begin
103         if g_job_id  is  null then
104             g_job_id := job_log_id_seq.nextval;
105         end if;
106         return g_job_id;
107     end;
108  */
109    /*
110    procedure update_tracefile_name(p_tracefile_name in varchar) is
111       pragma autonomous_transaction ;
112    begin
113  	  update job_log set tracefile_name = p_tracefile_name 
114  	  where job_log_id = g_job_id;
115  	  commit;
116    end;
117    */
118  
119      procedure use_logger_set(p_set_nm in varchar) 
120      is
121          no_such_logger_set exception;
122      begin
123         dbms_output.put_line('use_logger_set "' || p_set_nm || '"');
124         select * into g_logger_hdr from logger_hdr 
125         where logger_set_nm = upper(p_set_nm);
126  
127         exception when
128             no_data_found then raise_application_error(-200001,'no_such_logger_set ' || p_set_nm);
129  
130         for dtl in ( select * 
131         from logger_dtl
132         where logger_hdr_id = g_logger_hdr.logger_hdr_id)
133         loop
134             logger_dtls(upper(dtl.logger_nm)) := dtl;
135         end loop;
136      end;
137  
138      procedure logger_dtls_to_str is
139          ndx varchar(64);
140          dtl logger_dtl%rowtype;
141          retval long := '';
142      begin
143          dbms_output.put_line('logger_dtls_to_str');
144         -- dbms_output.put_line('about to get first');
145         -- ndx := logger_dtls.first();
146          -- dbms_output.put_line('ndx "' || ndx || '"');
147  
148          while ndx is not null loop
149              dtl :=  logger_dtls(ndx);
150              retval := retval || dtl.logger_nm  || ' ' || dtl.log_lvl || '\n';
151              ndx := logger_dtls.next(ndx);
152          end loop;
153          dbms_output.put_line('>> ' || retval);
154         -- dbms_output.put_line('end logger_dtls_to_str');
155      end logger_dtls_to_str;
156  
157      function get_log_level (p_logger_name in varchar) 
158      return number 
159      is 
160          my_logger_name varchar(64) := upper(p_logger_name);
161          my_log_dtl logger_dtl%rowtype;
162          retval number;
163      begin 
164           dbms_output.put_line('get_log_level()  p_logger_name *' || p_logger_name || ' my_logger_name *' || my_logger_name || '*');
165           logger_dtls_to_str;
166  
167           begin
168               my_log_dtl  := logger_dtls(my_logger_name);
169               retval := my_log_dtl.log_lvl;
170           exception 
171              when no_data_found then
172               dbms_output.put_line('logger not found ' || my_logger_name);
173               retval := g_filter_level;
174           end;
175  
176          dbms_output.put_line('get_log_level() ====> ' || p_logger_name || ' ' || to_char(my_log_dtl.log_lvl) || ' retval ' || to_char(retval));
177  
178          return retval;
179  
180      end get_log_level;
181    --::<
182    procedure create_process_log (
183        -- TODO no database updates, no commit or autonomous required
184  
185        p_job_log_id   in   pls_integer,
186        p_job_msg_id   in   pls_integer,
187        p_log_msg      in   varchar2,
188        p_log_level    in   pls_integer,
189        p_elapsed_time in   INTERVAL DAY TO SECOND DEFAULT NULL, -- TODO not recorded at this time
190        p_caller_name  in   varchar2,
191        p_line_number  in   pls_integer,
192        p_call_stack   in   varchar2 DEFAULT NULL
193     )
194     is
195        my_message   varchar2 (32767);
196        -- my_msg       varchar2 (32767);
197        now          timestamp        := SYSDATE;
198        --pragma autonomous_transaction ;
199        -- short_message varchar2(255);
200        -- long_message  clob;
201        my_log_file_name varchar2(4000);
202        my_logger_level number;
203  
204     begin
205         if p_caller_name is not null then  -- TODO make it work with null
206             my_logger_level := get_log_level(p_caller_name);
207          else
208             my_logger_level := g_filter_level;
209         end if;
210         g_next_log_seq_nbr := 1;
211        if g_log_file_name is NULL then  -- TODO name shoul be in one place
212           g_log_file_name := g_process_name || '_' || to_char (current_timestamp, 'YYYY-MM-DD_HH24MisSXFF');
213        end if;
214        my_log_file_name := open_log_file (g_log_file_name);  -- TODO why pass a global
215        g_next_log_seq_nbr := g_next_log_seq_nbr + 1;         -- TODO doesnt work with multitask
216        if g_debug then 
217          dbms_output.put_line('open_log_file' || g_log_file_name);
218          dbms_output.put_line('my_log_file_name: ' || my_log_file_name);
219          dbms_output.put_line('g_next_log_seq_nbr ' || g_next_log_seq_nbr);
220        end if;
221  
222        if p_log_level <= my_logger_level then
223            g_next_log_seq_nbr := g_next_log_seq_nbr + 1;   -- TODO this should go as too much work if multiple connections
224  
225            my_message := logger_message_formatter  (
226                job_log_id   => p_job_log_id,
227                job_msg_id   => p_job_msg_id,
228                log_msg      => p_log_msg,
229                log_level    => p_log_level,
230                caller_name  => p_caller_name,
231                line_number  => p_line_number,
232                call_stack   => p_call_stack
233            );
234       	  dbms_output.put_line('create_process_log about to write ' || to_char(p_log_level) || my_message); 
235       	  --dbms_output.put_line('p_caller_name ' || p_caller_name);
236       	  --dbms_output.put_line('p_line_number ' || p_line_number);
237  
238            UTL_FILE.put_line (g_file_handle, my_message);
239        else
240            dbms_output.put_line('create_process_log() p_log_level skip ' || to_char(p_log_level) || ' my_logger_level ' || to_char(my_logger_level));
241  
242        end if;
243        -- commit;
244     end create_process_log;
245  
246     -- TODO bad name
247     --<
248     procedure TRACE (p_string in varchar2)
249     --% procedure TRACE (p_string in varchar2)
250     --% Write the messsage to dbms_output
251     -->
252     is
253     begin
254        dbms_output.put_line (p_string);
255     end TRACE;
256  
257  -- public
258     procedure set_dbms_output_level (p_level in pls_integer)
259     is
260     begin
261        g_dbms_output_level := p_level;
262     end set_dbms_output_level;
263  
264     procedure close_log_file
265     is
266     begin
267        if utl_file.is_open (g_file_handle) then
268            utl_file.fclose (g_file_handle);
269        end if;
270     end close_log_file;
271  
272     procedure log_level (
273        p_log_msg       in   varchar2,
274        p_log_level     in   pls_integer,
275        p_caller_name   in   varchar2 DEFAULT NULL,
276        p_line_number   in   pls_integer DEFAULT NULL,
277        p_call_stack    in   varchar2 DEFAULT NULL
278     )
279     is
280        log_time       timestamp  := current_timestamp;
281        elapsed        INTERVAL DAY TO SECOND;
282        my_log_level   pls_integer;
283     begin
284        my_log_level := p_log_level;
285  
286        if my_log_level < 1 then my_log_level := 1; end if;
287        if my_log_level > 9 then my_log_level := 9; end if;
288  
289        -- dbms_output.put_line('about to create process log');
290        --utl_file.put_line(g_file_handle, p_log_msg);  -- TODO
291        create_process_log (p_job_log_id  => g_job_log.job_log_id,
292                            p_job_msg_id            => NULL,
293                            p_log_msg               => p_log_msg,
294                            p_log_level             => my_log_level,
295                            p_elapsed_time          => elapsed,
296                            p_caller_name           => p_caller_name,
297                            p_line_number           => p_line_number,
298                            p_call_stack            => p_call_stack
299                           );
300     end log_level;
301  
302  
303     procedure LOG (p_level in pls_integer, p_log_msg IN varchar2)
304     is
305     begin
306        log_level (p_log_level        => p_level,
307                   p_log_msg          => p_log_msg,
308                   p_caller_name      => g_caller_name,
309                   p_line_number      => g_line_number
310                  );
311     end LOG;
312  
313     procedure severe (
314        p_unit           in   varchar2,
315        p_line           in   pls_integer,
316        p_log_msg        in   varchar2 DEFAULT '',
317        p_record_stack   in   BOOLEAN default false
318     )
319     is
320        stack   varchar2 (32767);
321     begin
322        if p_record_stack then
323           stack := DBMS_UTILITY.format_call_stack ();
324        end if;
325  
326        log_level (p_log_level        => g_severe,
327                   p_log_msg          => p_log_msg,
328                   p_caller_name      => p_unit,
329                   p_line_number      => p_line,
330                   p_call_stack       => stack
331                  );
332     end severe;
333  
334     procedure warning (
335        p_unit           in   varchar2,
336        p_line           in   pls_integer,
337        p_log_msg        in   varchar2,
338        p_record_stack   in   BOOLEAN
339     )
340     is
341        stack   varchar2 (32767);
342     begin
343        if p_record_stack then
344           stack := DBMS_UTILITY.format_call_stack ();
345        end if;
346  
347        log_level (p_log_level        => g_warning,
348                   p_log_msg          => p_log_msg,
349                   p_caller_name      => p_unit,
350                   p_line_number      => p_line,
351                   p_call_stack       => stack
352                  );
353     end warning;
354  
355  
356     procedure log_snap (
357        p_unit      in   varchar2,
358        p_line      in   pls_integer,
359        p_log_msg   in   varchar2
360     )
361     is
362     begin
363        OWA_UTIL.who_called_me (g_owner_name,
364                                g_caller_name,
365                                g_line_number,
366                                g_caller_type
367                               );
368  
369        log_level (p_log_level        => g_snap,
370                   p_log_msg          => p_log_msg,
371                   p_caller_name      => g_caller_name,
372                   p_line_number      => g_line_number
373                  );
374     end log_snap;
375  
376     procedure entering (
377        p_unit           in   varchar2,
378        p_line           in   pls_integer,
379        p_log_msg        in   varchar2 DEFAULT '',
380        p_record_stack   in   BOOLEAN DEFAULT FALSE,
381        p_set_action     in   BOOLEAN DEFAULT TRUE
382     )
383     is
384        stack   varchar2 (32767) := NULL;
385     begin
386        if p_record_stack then
387           stack := DBMS_UTILITY.format_call_stack ();
388        end if; 
389        log_level (p_log_level        => g_entering,
390                   p_log_msg          => p_log_msg,
391                   p_caller_name      => p_unit,
392                   p_line_number      => p_line,
393                   p_call_stack       => stack
394                  );
395        if p_set_action then dbms_application_info.set_action($$PLSQL_UNIT) ; end if;
396     end entering;
397  
398     procedure exiting (
399        p_unit           in   varchar2,
400        p_line           in   pls_integer,
401        p_log_msg        in   varchar2,
402        p_record_stack   in   BOOLEAN
403     )
404     is
405        stack   varchar2 (32767);
406     begin
407        if p_record_stack then
408           stack := DBMS_UTILITY.format_call_stack ();
409        end if;
410  
411        log_level (p_log_level        => g_exiting,
412                   p_log_msg          => p_log_msg,
413                   p_caller_name      => p_unit,
414                   p_line_number      => p_line,
415                   p_call_stack       => stack
416                  );
417        dbms_application_info.set_action('');
418     end exiting;
419  
420     procedure fine (
421        p_unit           in   varchar2,
422        p_line           in   pls_integer,
423        p_log_msg        in   varchar2,
424        p_record_stack   in   BOOLEAN
425     )
426     is
427        stack   varchar2 (32767);
428     begin
429        if p_record_stack then
430           stack := DBMS_UTILITY.format_call_stack ();
431        end if;
432  
433        log_level (p_log_level        => g_fine,
434                   p_log_msg          => p_log_msg,
435                   p_caller_name      => p_unit,
436                   p_line_number      => p_line,
437                   p_call_stack       => stack
438                  );
439     end fine;
440  
441     procedure finer (
442        p_unit           in   varchar2,
443        p_line           in   pls_integer,
444        p_log_msg        in   varchar2,
445        p_record_stack   in   BOOLEAN DEFAULT FALSE
446     )
447     is
448        stack   varchar2 (32767);
449     begin
450        if p_record_stack then 
451          stack := DBMS_UTILITY.format_call_stack (); 
452     end if;
453  
454        log_level (p_log_level        => g_finer,
455                   p_log_msg          => p_log_msg,
456                   p_caller_name      => p_unit,
457                   p_line_number      => p_line,
458                   p_call_stack       => stack
459                  );
460     end finer;
461  
462     procedure finest (
463        p_unit           in   varchar2,
464        p_line           in   pls_integer,
465        p_log_msg        in   varchar2,
466        p_record_stack   in   BOOLEAN DEFAULT FALSE
467     )
468     is
469        stack   varchar2 (32767);
470     begin
471        if p_record_stack then stack := DBMS_UTILITY.format_call_stack (); end if;
472  
473        log_level (p_log_level        => g_finest,
474                   p_log_msg          => p_log_msg,
475                   p_caller_name      => p_unit,
476                   p_line_number      => p_line,
477                   p_call_stack       => stack
478                  );
479     end finest;
480  
481     procedure LOG (
482        p_msg_id         in   varchar2,
483        p_log_msg        in   varchar2,
484        p_long_msg       in   varchar2,
485        p_elapsed_time   in   INTERVAL DAY TO SECOND DEFAULT NULL,
486        p_log_level      in   pls_integer,
487        p_call_stack     in   varchar2 DEFAULT NULL
488     )
489     is
490        my_log_time    timestamp ( 6 )        := current_timestamp;
491        my_elapsed     INTERVAL DAY TO SECOND;
492        my_log_level   pls_integer;
493     begin
494        my_log_level := p_log_level;
495  
496        if my_log_level < 1 then my_log_level := 1; end if;
497        if my_log_level > 9 then my_log_level := 9; end if;
498  
499        create_process_log (p_job_log_id   => g_job_log.job_log_id,
500                            p_job_msg_id              => p_msg_id,
501                            p_log_msg                 => p_log_msg,
502                            p_log_level               => my_log_level,
503                            p_elapsed_time            => my_elapsed,
504                            p_caller_name             => g_caller_name,
505                            p_line_number             => g_line_number,
506                            p_call_stack              => p_call_stack
507                           );
508     end LOG;
509  
510  
511     procedure set_filter_level (p_level in pls_integer)
512     is
513     begin
514        if    p_level < 1 then g_filter_level := 1;
515        elsif p_level > 9 then g_filter_level := 9;
516        else  g_filter_level := p_level; 
517        end if;
518     end set_filter_level;
519  
520     /**
521      procedure set_record_level (p_level in pls_integer)
522     */
523     procedure set_record_level (p_level in pls_integer)
524     is
525     begin
526        if    p_level < 1 then g_record_level := 1;
527        elsif p_level > 9 then g_record_level := 9;
528        else  g_record_level := p_level;
529        end if;
530     end set_record_level;
531  
532     function get_directory_path return varchar is
533        -- todo see if grants are wrong, permission must be granted to the user
534        cursor directory_cur is
535        select  owner, directory_name, directory_path
536        from    all_directories
537        where   directory_name = g_job_msg_dir;
538  
539        directory_rec directory_cur%rowtype;
540  
541      begin
542        open directory_cur;
543        fetch directory_cur into directory_rec;
544        dbms_output.put_line('owner: '           || directory_rec.owner ||
545                             ' directory_name: ' || directory_rec.directory_name ||
546                             ' directory_path: ' || directory_rec.directory_path);
547        close directory_cur;
548  
549        return directory_rec.directory_path;
550     end get_directory_path;
551  
552  
553    --::<
554    function basename (p_full_path in varchar2,
555                       p_suffix    in varchar2 default null,
556                       p_separator in char default '/')
557     return varchar2
558     --:: like bash basename or gnu basename, returns the filename of a path optionally
559     --:: stripping the specified file extension
560     --::>
561     is
562         my_basename varchar2(256);
563     begin
564         dbms_output.put_line('basename ' || p_full_path);
565         my_basename := substr(p_full_path, instr(p_full_path,p_separator,-1)+1);
566         dbms_output.put_line('my_basename' || my_basename);
567         if p_suffix is not null then
568            my_basename := substr(my_basename, 1, instr(my_basename, p_suffix, -1)-1);
569         end if;
570         return my_basename;
571     end basename;
572  
573  
574     procedure info (
575        p_unit           in   varchar2,       -- should be set with $$PLSQL_UNIT
576        p_line           in   pls_integer,    -- should be set with $$PLSQL_LINE
577        p_log_msg        in   varchar2,       -- the message to be logged
578        p_record_stack   in   BOOLEAN         -- record the call stack
579     )
580     is
581        stack   varchar2 (32767);
582     begin
583        if p_record_stack then
584          stack := dbms_utility.format_call_stack ();
585        end if;
586        log_level (p_log_level        => g_info,
587                   p_log_msg          => p_log_msg,
588                   p_caller_name      => p_unit,
589                   p_line_number      => p_line,
590                   p_call_stack       => stack
591                  );
592     end info;
593  
594      procedure set_action (p_action_name in varchar) is 
595      -- record the step name and then restore the action
596      -- the execute immediate makes sure the action is written to the trace file 
597      -- if there is no sql activity it is not written
598      begin
599         dbms_application_info.set_action(p_action_name);
600         execute immediate 'select ''' || p_action_name || ''' from dual'; -- TODO why 
601      end;
602  
603      procedure set_job_msg_id (p_job_msg_id in pls_integer) is
604      begin
605          g_job_msg_id := p_job_msg_id;
606      end;
607  
608    --
609    --  Logger hdr and dtl
610    --
611  
612      procedure create_set (p_set_nm    in varchar,
613                          p_default_level     in number)
614      is
615      begin
616          insert into logger_hdr (logger_hdr_id, logger_set_nm, default_lvl)
617          values (logger_hdr_id_seq.nextval, upper(p_set_nm), p_default_level);
618       end create_set;
619  
620      procedure define_logger_level(p_set_nm    in varchar,
621                          p_logger_nm in varchar,
622                          p_level     in number)
623      is 
624          logger_rec logger_hdr%rowtype;
625  
626      begin
627  
628               insert into logger_dtl (logger_dtl_id, logger_hdr_id, 
629                       logger_nm, log_lvl)
630               select logger_dtl_id_seq.nextval, 
631                      logger_hdr.logger_hdr_id,
632                      upper(p_logger_nm), p_level
633               from   logger_hdr 
634               where 
635                     logger_set_nm = upper(p_set_nm);
636  
637               exception when dup_val_on_index 
638               then
639                   update logger_dtl 
640                   set  log_lvl =  p_level
641                   where logger_hdr_id =  (
642                           select logger_hdr_id 
643                           from   logger_hdr
644                           where logger_set_nm = upper(p_set_nm) 
645  			)
646                           and logger_nm = upper(p_logger_nm);
647  
648  
649  
650      end define_logger_level;
651  
652  
653  
654  
655  begin
656     dbms_output.ENABLE(1000000) ;
657  end pllogger;
658  /

Package Body PLLOGGER compiled

SQL> --#<
SQL> show errors
SQL> --#>
@
